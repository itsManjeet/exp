// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Modgraphviz converts “go mod graph” output into Graphviz's DOT language,
// for use with Graphviz visualization and analysis tools like dot, dotty, and sccmap.
//
// Usage:
//
//	go mod graph | modgraphviz > graph.dot
//	go mod graph | modgraphviz | dot -Tpng -o graph.png
//
// Modgraphviz takes no options or arguments; it reads a graph in the format
// generated by “go mod graph” on standard input and writes DOT language
// on standard output.
//
// For each module, the node representing the greatest version (i.e., the
// version chosen by Go's minimal version selection algorithm) is colored green.
// Other nodes, which aren't in the final build list, are colored grey.
//
// See http://www.graphviz.org/doc/info/lang.html for details of the DOT language
// and http://www.graphviz.org/about/ for Graphviz itself.
//
// See also golang.org/x/tools/cmd/digraph for general queries and analysis
// of “go mod graph” output.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"strings"
)

func usage() {
	fmt.Fprintf(os.Stderr, `Usage: go mod graph | modgraphviz | dot -Tpng -o graph.png

For each module, the node representing the greatest version (i.e., the
version chosen by Go's minimal version selection algorithm) is colored green.
Other nodes, which aren't in the final build list, are colored grey.
`)
	os.Exit(2)
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("modgraphviz: ")

	flag.Usage = usage
	flag.Parse()
	if flag.NArg() != 0 {
		usage()
	}

	if err := modgraphviz(os.Stdin, os.Stdout); err != nil {
		log.Fatal(err)
	}
}

func modgraphviz(in io.Reader, out io.Writer) error {
	var buf bytes.Buffer
	if _, err := io.Copy(&buf, in); err != nil {
		return err
	}

	lines := strings.Split(buf.String(), "\n")
	firstLine := lines[0]
	parts := strings.Split(firstLine, " ")
	rootVertex := parts[0]

	graph, err := convert(bytes.NewBufferString(buf.String()))
	if err != nil {
		return err
	}

	g2, err := convert2(bytes.NewBufferString(buf.String()))
	if err != nil {
		return err
	}
	rootGraph, subGraphs, err := g2.allSubgraphs(rootVertex, 7)
	if err != nil {
		return err
	}

	// ~/workspace/google-api-go-client && go mod graph | ~/workspace/exp/cmd/modgraphviz/modgraphviz | dot -Tpng -o graph.png; open graph.png
	// TODO: non-deterministic
	// TODO: sometimes generates subgraphs with two bridges instead of just one (maybe cutgraphs is doing the wrong thing?)

	fmt.Fprintf(out, "digraph gomodgraph {\n")
	fmt.Fprintf(out, "\tnode [ shape=rectangle fontsize=12 ]\n")
	// out.Write(graph.edgesAsDOT())
	for v, succs := range rootGraph.vertices {
		for succ := range succs {
			fmt.Fprintf(out, "\t%q -> %q\n", v, succ)
		}
	}
	for i, subGraph := range subGraphs {
		fmt.Fprintf(out, "\tsubgraph cluster_%d {\n", i)
		if len(subGraph.vertices) == 1 {
			// Only applicable in the cut1(minVertices=1) case.
			for v := range subGraph.vertices {
				fmt.Fprintf(out, "\t\t%q\n", v)
			}
		} else {
			for v, succs := range subGraph.vertices {
				for succ := range succs {
					fmt.Fprintf(out, "\t\t%q -> %q\n", v, succ)
				}
			}
		}
		// fmt.Fprint(out, "\t\t[margin=50]\n")
		fmt.Fprint(out, "\t}\n")
	}
	// fmt.Fprint(out, "\tstyle=invis")
	for _, n := range graph.mvsPicked {
		fmt.Fprintf(out, "\t%q [style = filled, fillcolor = green]\n", n)
	}
	for _, n := range graph.mvsUnpicked {
		fmt.Fprintf(out, "\t%q [style = filled, fillcolor = gray]\n", n)
	}
	fmt.Fprintf(out, "}\n")

	return nil
}

type edge struct{ from, to string }
type nodeset map[string]bool
