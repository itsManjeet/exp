// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Modgraphviz converts “go mod graph” output into Graphviz's DOT language,
// for use with Graphviz visualization and analysis tools like dot, dotty, and sccmap.
//
// Usage:
//
//	go mod graph | modgraphviz > graph.dot
//	go mod graph | modgraphviz | dot -Tpng -o graph.png
//
// Modgraphviz takes no options or arguments; it reads a graph in the format
// generated by “go mod graph” on standard input and writes DOT language
// on standard output.
//
// For each module, the node representing the greatest version (i.e., the
// version chosen by Go's minimal version selection algorithm) is colored green.
// Other nodes, which aren't in the final build list, are colored grey.
//
// See http://www.graphviz.org/doc/info/lang.html for details of the DOT language
// and http://www.graphviz.org/about/ for Graphviz itself.
//
// See also golang.org/x/tools/cmd/digraph for general queries and analysis
// of “go mod graph” output.
package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"sort"
	"strings"

	"golang.org/x/mod/semver"
)

func usage() {
	fmt.Fprintf(os.Stderr, `Usage: go mod graph | modgraphviz | dot -Tpng -o graph.png

For each module, the node representing the greatest version (i.e., the
version chosen by Go's minimal version selection algorithm) is colored green.
Other nodes, which aren't in the final build list, are colored grey.
`)
	os.Exit(2)
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("modgraphviz: ")

	flag.Usage = usage
	flag.Parse()
	if flag.NArg() != 0 {
		usage()
	}

	graph, nodes, err := convert(os.Stdin)
	if err != nil {
		log.Fatal(err)
	}

	pickedNodes, unpickedNodes, err := colorNodes(nodes)
	if err != nil {
		log.Fatal(err)
	}

	out := bytes.Buffer{}
	fmt.Fprintf(&out, "digraph gomodgraph {\n")
	out.Write(graph)
	for _, n := range pickedNodes {
		fmt.Fprintf(&out, "\t%q [style = filled, fillcolor = green]\n", n)
	}
	for _, n := range unpickedNodes {
		fmt.Fprintf(&out, "\t%q [style = filled, fillcolor = gray]\n", n)
	}
	out.WriteString("}\n")
	if _, err := out.WriteTo(os.Stdout); err != nil {
		log.Fatal(err)
	}
}

// convert reads “go mod graph” output from r and returns the equivalent DOT
// digraph as well as a list of all the nodes.
func convert(r io.Reader) ([]byte, []string, error) {
	var buf bytes.Buffer
	var nodes []string
	scanner := bufio.NewScanner(r)
	for scanner.Scan() {
		parts := strings.Fields(scanner.Text())
		if len(parts) != 2 {
			continue
		}
		from := parts[0]
		to := parts[1]

		nodes = append(nodes, from)
		nodes = append(nodes, to)
		fmt.Fprintf(&buf, "\t%q -> %q\n", from, to)
	}
	if err := scanner.Err(); err != nil {
		return nil, nil, err
	}

	return buf.Bytes(), nodes, nil
}

// colorNodes returns the set of nodes that mvs picked, and the set of nodes it
// did not pick.
//
// See more on MVS at https://research.swtch.com/vgo-mvs.
func colorNodes(nodes []string) ([]string, []string, error) {
	// Dedupe nodes.
	nodeSet := make(map[string]bool)
	for _, n := range nodes {
		nodeSet[n] = true
	}
	nodes = make([]string, len(nodeSet))
	var i int
	for n := range nodeSet {
		nodes[i] = n
		i++
	}

	moduleVersions := make(map[string]map[string][]string) // module -> major -> []version
	for _, n := range nodes {
		parts := strings.Split(n, "@")
		if len(parts) != 2 {
			// Root node doesn't have a version.
			continue
		}
		module := parts[0]
		version := parts[1]
		if !semver.IsValid(version) {
			return nil, nil, fmt.Errorf("%s does not contain a valid semver version", n)
		}
		major := semver.Major(version)
		if _, ok := moduleVersions[module]; !ok {
			moduleVersions[module] = make(map[string][]string)
		}
		moduleVersions[module][major] = append(moduleVersions[module][major], version)
	}

	var picked []string
	var unpicked []string

	for m, majorVersions := range moduleVersions {
		for major, versions := range majorVersions {
			if major == "v0" {
				// If there's a v1 and also a v0, all v0s are unpicked (any v1
				// takes precedence).
				if _, ok := majorVersions["v1"]; ok {
					for _, v := range versions {
						unpicked = append(unpicked, m+"@"+v)
					}
					continue
				}
			}

			sort.Slice(versions, func(i, j int) bool {
				return semver.Compare(versions[i], versions[j]) == 1
			})
			picked = append(picked, m+"@"+versions[0])
			for _, v := range versions[1:] { // Skip the first one - it's already in "picked".
				unpicked = append(unpicked, m+"@"+v)
			}
		}
	}

	// Make this function deterministic.
	sort.Strings(picked)
	sort.Strings(unpicked)

	return picked, unpicked, nil
}
