// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Modgraphviz converts “go mod graph” output into Graphviz's DOT language,
// for use with Graphviz visualization and analysis tools like dot, dotty, and sccmap.
//
// Usage:
//
//	go mod graph | modgraphviz > graph.dot
//	go mod graph | modgraphviz | dot -Tpng -o graph.png
//
// Modgraphviz takes no options or arguments; it reads a graph in the format
// generated by “go mod graph” on standard input and writes DOT language
// on standard output.
//
// Nodes picked by MVS are colored green, whilst all other nodes are colored are
// colored gray.
//
// See http://www.graphviz.org/doc/info/lang.html for details of the DOT language
// and http://www.graphviz.org/about/ for Graphviz itself.
//
// See also golang.org/x/tools/cmd/digraph for general queries and analysis
// of “go mod graph” output.
package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"sort"
	"strconv"
	"strings"
)

func usage() {
	fmt.Fprintf(os.Stderr, `Usage: go mod graph | modgraphviz | dot -Tpng -o graph.png

Nodes picked by MVS are colored green, whilst all other nodes are colored gray.
`)
	os.Exit(2)
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("modgraphviz: ")

	flag.Usage = usage
	flag.Parse()
	if flag.NArg() != 0 {
		usage()
	}

	graph, nodes, err := convert(os.Stdin)
	if err != nil {
		log.Fatal(err)
	}

	greenNodes, grayNodes, err := colourNodes(nodes)
	if err != nil {
		log.Fatal(err)
	}

	out := bytes.Buffer{}
	fmt.Fprintf(&out, "digraph gomodgraph {\n")
	out.Write(graph)
	for _, n := range greenNodes {
		fmt.Fprintf(&out, "\t%q [style = filled, fillcolor = green]\n", n)
	}
	for _, n := range grayNodes {
		fmt.Fprintf(&out, "\t%q [style = filled, fillcolor = gray]\n", n)
	}
	out.WriteString("}\n")
	if _, err := out.WriteTo(os.Stdout); err != nil {
		log.Fatal(err)
	}
}

// convert reads “go mod graph” output from r and returns the equivalent DOT
// digraph as well as a list of all the nodes.
func convert(r io.Reader) ([]byte, []string, error) {
	var buf bytes.Buffer
	var nodes []string
	scanner := bufio.NewScanner(r)
	for scanner.Scan() {
		parts := strings.Fields(scanner.Text())
		if len(parts) != 2 {
			continue
		}
		from := parts[0]
		to := parts[1]

		nodes = append(nodes, from)
		nodes = append(nodes, to)
		fmt.Fprintf(&buf, "\t%q -> %q\n", from, to)
	}
	if err := scanner.Err(); err != nil {
		return nil, nil, err
	}

	return buf.Bytes(), nodes, nil
}

// colourNodes returns a set of nodes that mvs picked - "green" nodes - and the
// remaining nodes, which mvs did not pick - "gray" nodes.
//
// See more on MVS at https://research.swtch.com/vgo-mvs.
func colourNodes(nodes []string) ([]string, []string, error) {
	// Dedupe nodes.
	nodeSet := make(map[string]bool)
	for _, n := range nodes {
		nodeSet[n] = true
	}
	nodes = make([]string, len(nodeSet))
	var i int
	for n := range nodeSet {
		nodes[i] = n
		i++
	}

	moduleVersions := make(map[string]map[int][]string) // module -> major -> []version
	for _, n := range nodes {
		parts := strings.Split(n, "@v")
		if len(parts) != 2 {
			// Root node doesn't have a version.
			continue
		}
		module := parts[0]
		version := parts[1]
		major, err := strconv.Atoi(string(version[0]))
		if err != nil {
			return nil, nil, err
		}
		if _, ok := moduleVersions[module]; !ok {
			moduleVersions[module] = make(map[int][]string)
		}
		moduleVersions[module][major] = append(moduleVersions[module][major], version)
	}

	var green []string
	var gray []string

	for m, majorVersions := range moduleVersions {
		for major, versions := range majorVersions {
			if major == 0 {
				// If there's a v1 and also a v0, all v0s are gray (any v1
				// takes precedence).
				if _, ok := majorVersions[1]; ok {
					for _, v := range versions {
						gray = append(gray, m+"@v"+v)
					}
					continue
				}
			}

			sort.Slice(versions, func(i, j int) bool {
				return strings.Compare(versions[i], versions[j]) == 1
			})
			green = append(green, m+"@v"+versions[0])
			for _, v := range versions[1:] { // Skip the first one - it's already in green.
				gray = append(gray, m+"@v"+v)
			}
		}
	}

	// Make this function deterministic.
	sort.Strings(green)
	sort.Strings(gray)

	return green, gray, nil
}
