{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b16eed48_acd17694",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-08-01T12:08:02Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003dd8e44b77\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "36a009dd_c01208d7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-08-01T12:10:14Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "b16eed48_acd17694",
      "tag": "autogenerated:trybots~happy",
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1341c6d0_129022cc",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 87,
      "author": {
        "id": 31647
      },
      "writtenOn": "2023-08-02T18:08:58Z",
      "side": 1,
      "message": "Throughout: please use `Var.Embedded` (I forgot that `Anonymous` even existed).\n\nNot for this CL.",
      "range": {
        "startLine": 87,
        "startChar": 10,
        "endLine": 87,
        "endChar": 19
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b1a2dfd_f842d254",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 129,
      "author": {
        "id": 31647
      },
      "writtenOn": "2023-08-02T18:08:58Z",
      "side": 1,
      "message": "Ok, there\u0027s something philosophical that I\u0027m not quite grokking here. Let me take a stab in the dark.\n\nIn this case, we say that we only establish correspondence between old and new if new is Named or Basic. We don\u0027t establish correspondence with other types, I think because we want better error messages.\n\nBut there is also logic in establishCorrespondence that exits early before writing the correspondMap. So this logic of not recording the correspondence is split between the call site here and the internals of establishCorrespondence.\n\nCan we consolidate that logic into establishCorrespondence, so that this callsite is unconditional (i.e. just `d.establishCorrespondence(old, new)`? Inside establishCorrespondence, can we explain which conditions we want to check before writing the correspondMap, and which we want to check after, and why?",
      "range": {
        "startLine": 122,
        "startChar": 0,
        "endLine": 129,
        "endChar": 0
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "170d32e1_e8ac6290",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 129,
      "author": {
        "id": 14570
      },
      "writtenOn": "2023-08-04T12:39:57Z",
      "side": 1,
      "message": "I see what you mean about the split logic. I did the refactoring you suggest.\n\nBut you got me thinking about correspondence with basic types. I may have made a wrong turn there. I wrote in two places in this code that basic types are defined types, but according to the current spec at least (and maybe always), they are not. Correspondence is supposed to be only for defined types.\n\nThe reason it makes sense at all is that, as long as the old defined type had no methods, the change is compatible because operators still work. For example:\n\n    // old\n    type t int\n    var V t\n    \n    // new\n    var V int\n \nI believe that if there were no methods on t, then anything client code could do with the old V it could also do with the new V. Since t is unexported, client code can\u0027t use the type name. So this is a compatible change. If t did have a method M, apidiff would say \"t.M removed\".\n \nSo allowing basic types to correspond is more generous than not, even though it\u0027s not strictly correct. I\u0027d be okay removing it if you think it\u0027s confusing. I doubt these sort of cases come up in practice.",
      "parentUuid": "2b1a2dfd_f842d254",
      "range": {
        "startLine": 122,
        "startChar": 0,
        "endLine": 129,
        "endChar": 0
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a3d1826_022d4a24",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 129,
      "author": {
        "id": 31647
      },
      "writtenOn": "2023-08-07T13:46:29Z",
      "side": 1,
      "message": "I agree it\u0027s unlikely.\n\nFrom the spec:\n```\n\"Predeclared types, defined types, and type parameters are called named types. An alias denotes a named type if the type given in the alias declaration is a named type.\"\n```\n\nSo basic types are defined, for the purpose of e.g. assignability checks.\n\nI actually think that it\u0027s probably better to think in terms of _behaviors_ (i.e. operators, selectors, assignments, conversions, etc. that are valid with a particular type). If we expressed this package in those terms, I think it would be easier to follow, though perhaps more verbose.\n\nWhat you\u0027ve done is almost like implementing a looser form of type identity (https://go.dev/issue/57497), with the exception of this flexibility about basic types. If you wanted to remove this flexibility, I do think the code would be easier to read, but it\u0027s fine to leave (perhaps with more commentary).\n\nBTW, I just discovered the extensive README for this package, which I should have read first (I had looked for package doc). I\u0027ll read that.",
      "parentUuid": "170d32e1_e8ac6290",
      "range": {
        "startLine": 122,
        "startChar": 0,
        "endLine": 129,
        "endChar": 0
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "91bdc0dd_9eda7587",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 129,
      "author": {
        "id": 14570
      },
      "writtenOn": "2023-08-07T14:21:00Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "4a3d1826_022d4a24",
      "range": {
        "startLine": 122,
        "startChar": 0,
        "endLine": 129,
        "endChar": 0
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "86eade4e_0269afc4",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 152,
      "author": {
        "id": 31647
      },
      "writtenOn": "2023-08-02T18:08:58Z",
      "side": 1,
      "message": "FWIW, I don\u0027t really understand this.\n\nDon\u0027t you need to also compare the names of embedded fields.\nWhy does this particular case establish a correspondence between named types.",
      "range": {
        "startLine": 152,
        "startChar": 12,
        "endLine": 152,
        "endChar": 35
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "969b0c28_548bc775",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 152,
      "author": {
        "id": 14570
      },
      "writtenOn": "2023-08-04T12:39:57Z",
      "side": 1,
      "message": "There are three cases, illustrated here:\n\n    type S struct {\n        F int // normal field\n        T     // embedded exported field\n        u     // embedded unexported field\n    }\n    \nFor the first case, we just compare the names, as the first sentence of the doc says.\n\nFor the second case, we can also just compare names. Since the type is exported, somewhere else we\u0027ll deal whether the old and new types correspond. (The main loop of apidiff.Changes looks at all exported symbols.) Here we just need to make sure that client code like `s.T` compiles in both cases, which means the names have to match.\n\nFor the third case, since `u` is unexported we may never visit it elsewhere. So we check correspondence here. That will recursively check the fields of old and new `u`.\n\nI certainly may have missed something here, so if you still think something\u0027s off, please do holler.",
      "parentUuid": "86eade4e_0269afc4",
      "range": {
        "startLine": 152,
        "startChar": 12,
        "endLine": 152,
        "endChar": 35
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b57e8f50_537e5459",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 152,
      "author": {
        "id": 31647
      },
      "writtenOn": "2023-08-07T13:46:29Z",
      "side": 1,
      "message": "```\n// old\ntype u interface { m(); n() }\n\ntype S struct { u }\n\n// new\ntype u1 interface { m(); }\ntype u2 interface { n(); }\n\ntype S struct { u1; u2 }\n```\n\nIs this a breaking change?",
      "parentUuid": "969b0c28_548bc775",
      "range": {
        "startLine": 152,
        "startChar": 12,
        "endLine": 152,
        "endChar": 35
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "98dc8dfa_bdb92b0f",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 152,
      "author": {
        "id": 14570
      },
      "writtenOn": "2023-08-07T14:21:00Z",
      "side": 1,
      "message": "I say no, it\u0027s not a breaking change.\nSo does apidiff.\n(Which means the code implements my understanding, but not of course that it\u0027s right!)\n\nClient code can\u0027t construct an S (except for untagged literals, which we explicitly exclude). It also can\u0027t call methods on S. So it can\u0027t tell the difference between old and new S.\n\nThe same would be true if the methods were exported. The method sets are identical, so there is no observable difference.\n\nBTW, apidiff also reports compatible changes, like adding a method to a type. Neither of these cases is even a compatible change; they both result in an identical API from the client\u0027s POV.\n\nAm I missing something?",
      "parentUuid": "b57e8f50_537e5459",
      "range": {
        "startLine": 152,
        "startChar": 12,
        "endLine": 152,
        "endChar": 35
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cfd8482a_1977be5f",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 152,
      "author": {
        "id": 31647
      },
      "writtenOn": "2023-08-07T19:52:12Z",
      "side": 1,
      "message": "Sorry, I was trying to come up with an example of where corresponding unexported field types would cause apidiff to report mismatches where there were none. But you\u0027re right, it works (and I don\u0027t know why). Tried a few variations, and they all seem to work correctly...",
      "parentUuid": "98dc8dfa_bdb92b0f",
      "range": {
        "startLine": 152,
        "startChar": 12,
        "endLine": 152,
        "endChar": 35
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "feae3189_143113ae",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 152,
      "author": {
        "id": 14570
      },
      "writtenOn": "2023-08-08T09:14:05Z",
      "side": 1,
      "message": "As I tried to explain it to you, I realized I didn\u0027t know how it works either!\n\nI turns out that the code we\u0027re looking at here isn\u0027t involved at all. Old and new S correspond because they\u0027re defined types with the same name. We need to look at whether they are _compatible_. That is in checkCompatibleDefined, called on line 244 below. It\u0027s in the file compatibility.go, not part of this CL. But here is the relevant part:\n\n```\n// We need to check three things for structs:                                                                                                                                                                                                                                              \n//                                                                                                                                                                                                                                                                                         \n//  1. The set of exported fields must be compatible. This ensures that keyed struct                                                                                                                                                                                                       \n//     literals continue to compile. (There is no compatibility guarantee for unkeyed                                                                                                                                                                                                      \n//     struct literals.)                                                                                                                                                                                                                                                                   \n//                                                                                                                                                                                                                                                                                         \n//  2. The set of exported *selectable* fields must be compatible. This includes the exported                                                                                                                                                                                              \n//     fields of all embedded structs. This ensures that selections continue to compile.                                                                                                                                                                                                   \n//                                                                                                                                                                                                                                                                                         \n//  3. If the old struct is comparable, so must the new one be. This ensures that equality                                                                                                                                                                                                 \n//     expressions and uses of struct values as map keys continue to compile.                                                                                                                                                                                                              \n//                                                                                                                                                                                                                                                                                         \n// An unexported embedded struct can\u0027t appear in a struct literal outside the                                                                                                                                                                                                              \n// package, so it doesn\u0027t have to be present, or have the same name, in the new                                                                                                                                                                                                            \n// struct.                                                                                                                                                                                                                                                                                 \n//                                                                                                                                                                                                                                                                                         \n// Field tags are ignored: they have no compile-time implications.                                                                                                                                                                                                                         \nfunc (d *differ) checkCompatibleStruct(obj objectWithSide, old, new *types.Struct) {\n    d.checkCompatibleObjectSets(obj, exportedFields(old), exportedFields(new))\n    d.checkCompatibleObjectSets(obj, exportedSelectableFields(old), exportedSelectableFields(new))\n    // Removing comparability from a struct is an incompatible change.                                                                                                                                                                                                                     \n    if types.Comparable(old) \u0026\u0026 !types.Comparable(new) {\n        d.incompatible(obj, \"\", \"old is comparable, new is not\")\n    }\n}\n```\n\n\nSo when do we ask if two _struct types_ correspond (this code)? When a struct literal appears as the type of an exported object, like:\n\n    // old\n    var V struct{ A, B int }\n\n    // new                                                                                                                                                                                                                                                                                     \n    var V struct{ B, A int }\n    \nHere apidiff finds an incompatible change:\n\n    V: changed from struct{A int; B int} to struct{B int; A int}  \n    \nYou could argue that this is a compatible change, since the change in field name order can\u0027t matter here. But apidiff doesn\u0027t work that way, for reasons I explain in the \"Compatibility, Types and Names\" section of the README.",
      "parentUuid": "cfd8482a_1977be5f",
      "range": {
        "startLine": 152,
        "startChar": 12,
        "endLine": 152,
        "endChar": 35
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "75fc0d50_55713c17",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 152,
      "author": {
        "id": 31647
      },
      "writtenOn": "2023-08-11T13:49:17Z",
      "side": 1,
      "message": "Ack, thanks for the explanation.",
      "parentUuid": "feae3189_143113ae",
      "range": {
        "startLine": 152,
        "startChar": 12,
        "endLine": 152,
        "endChar": 35
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}