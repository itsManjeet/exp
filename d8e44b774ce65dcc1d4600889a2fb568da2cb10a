{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b16eed48_acd17694",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-08-01T12:08:02Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003dd8e44b77\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "36a009dd_c01208d7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2023-08-01T12:10:14Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "b16eed48_acd17694",
      "tag": "autogenerated:trybots~happy",
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1341c6d0_129022cc",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 87,
      "author": {
        "id": 31647
      },
      "writtenOn": "2023-08-02T18:08:58Z",
      "side": 1,
      "message": "Throughout: please use `Var.Embedded` (I forgot that `Anonymous` even existed).\n\nNot for this CL.",
      "range": {
        "startLine": 87,
        "startChar": 10,
        "endLine": 87,
        "endChar": 19
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b1a2dfd_f842d254",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 129,
      "author": {
        "id": 31647
      },
      "writtenOn": "2023-08-02T18:08:58Z",
      "side": 1,
      "message": "Ok, there\u0027s something philosophical that I\u0027m not quite grokking here. Let me take a stab in the dark.\n\nIn this case, we say that we only establish correspondence between old and new if new is Named or Basic. We don\u0027t establish correspondence with other types, I think because we want better error messages.\n\nBut there is also logic in establishCorrespondence that exits early before writing the correspondMap. So this logic of not recording the correspondence is split between the call site here and the internals of establishCorrespondence.\n\nCan we consolidate that logic into establishCorrespondence, so that this callsite is unconditional (i.e. just `d.establishCorrespondence(old, new)`? Inside establishCorrespondence, can we explain which conditions we want to check before writing the correspondMap, and which we want to check after, and why?",
      "range": {
        "startLine": 122,
        "startChar": 0,
        "endLine": 129,
        "endChar": 0
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "170d32e1_e8ac6290",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 129,
      "author": {
        "id": 14570
      },
      "writtenOn": "2023-08-04T12:39:57Z",
      "side": 1,
      "message": "I see what you mean about the split logic. I did the refactoring you suggest.\n\nBut you got me thinking about correspondence with basic types. I may have made a wrong turn there. I wrote in two places in this code that basic types are defined types, but according to the current spec at least (and maybe always), they are not. Correspondence is supposed to be only for defined types.\n\nThe reason it makes sense at all is that, as long as the old defined type had no methods, the change is compatible because operators still work. For example:\n\n    // old\n    type t int\n    var V t\n    \n    // new\n    var V int\n \nI believe that if there were no methods on t, then anything client code could do with the old V it could also do with the new V. Since t is unexported, client code can\u0027t use the type name. So this is a compatible change. If t did have a method M, apidiff would say \"t.M removed\".\n \nSo allowing basic types to correspond is more generous than not, even though it\u0027s not strictly correct. I\u0027d be okay removing it if you think it\u0027s confusing. I doubt these sort of cases come up in practice.",
      "parentUuid": "2b1a2dfd_f842d254",
      "range": {
        "startLine": 122,
        "startChar": 0,
        "endLine": 129,
        "endChar": 0
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a3d1826_022d4a24",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 129,
      "author": {
        "id": 31647
      },
      "writtenOn": "2023-08-07T13:46:29Z",
      "side": 1,
      "message": "I agree it\u0027s unlikely.\n\nFrom the spec:\n```\n\"Predeclared types, defined types, and type parameters are called named types. An alias denotes a named type if the type given in the alias declaration is a named type.\"\n```\n\nSo basic types are defined, for the purpose of e.g. assignability checks.\n\nI actually think that it\u0027s probably better to think in terms of _behaviors_ (i.e. operators, selectors, assignments, conversions, etc. that are valid with a particular type). If we expressed this package in those terms, I think it would be easier to follow, though perhaps more verbose.\n\nWhat you\u0027ve done is almost like implementing a looser form of type identity (https://go.dev/issue/57497), with the exception of this flexibility about basic types. If you wanted to remove this flexibility, I do think the code would be easier to read, but it\u0027s fine to leave (perhaps with more commentary).\n\nBTW, I just discovered the extensive README for this package, which I should have read first (I had looked for package doc). I\u0027ll read that.",
      "parentUuid": "170d32e1_e8ac6290",
      "range": {
        "startLine": 122,
        "startChar": 0,
        "endLine": 129,
        "endChar": 0
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "86eade4e_0269afc4",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 152,
      "author": {
        "id": 31647
      },
      "writtenOn": "2023-08-02T18:08:58Z",
      "side": 1,
      "message": "FWIW, I don\u0027t really understand this.\n\nDon\u0027t you need to also compare the names of embedded fields.\nWhy does this particular case establish a correspondence between named types.",
      "range": {
        "startLine": 152,
        "startChar": 12,
        "endLine": 152,
        "endChar": 35
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "969b0c28_548bc775",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 152,
      "author": {
        "id": 14570
      },
      "writtenOn": "2023-08-04T12:39:57Z",
      "side": 1,
      "message": "There are three cases, illustrated here:\n\n    type S struct {\n        F int // normal field\n        T     // embedded exported field\n        u     // embedded unexported field\n    }\n    \nFor the first case, we just compare the names, as the first sentence of the doc says.\n\nFor the second case, we can also just compare names. Since the type is exported, somewhere else we\u0027ll deal whether the old and new types correspond. (The main loop of apidiff.Changes looks at all exported symbols.) Here we just need to make sure that client code like `s.T` compiles in both cases, which means the names have to match.\n\nFor the third case, since `u` is unexported we may never visit it elsewhere. So we check correspondence here. That will recursively check the fields of old and new `u`.\n\nI certainly may have missed something here, so if you still think something\u0027s off, please do holler.",
      "parentUuid": "86eade4e_0269afc4",
      "range": {
        "startLine": 152,
        "startChar": 12,
        "endLine": 152,
        "endChar": 35
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b57e8f50_537e5459",
        "filename": "apidiff/correspondence.go",
        "patchSetId": 3
      },
      "lineNbr": 152,
      "author": {
        "id": 31647
      },
      "writtenOn": "2023-08-07T13:46:29Z",
      "side": 1,
      "message": "```\n// old\ntype u interface { m(); n() }\n\ntype S struct { u }\n\n// new\ntype u1 interface { m(); }\ntype u2 interface { n(); }\n\ntype S struct { u1; u2 }\n```\n\nIs this a breaking change?",
      "parentUuid": "969b0c28_548bc775",
      "range": {
        "startLine": 152,
        "startChar": 12,
        "endLine": 152,
        "endChar": 35
      },
      "revId": "d8e44b774ce65dcc1d4600889a2fb568da2cb10a",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}