{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6c02882a_8055e262",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-08-16T16:42:34Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003dd01e3ea6",
      "tag": "autogenerated:trybots~beginning",
      "revId": "d01e3ea68399a807f276143c8e0162e9f72e6bec",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3b57ed83_f0678700",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-08-16T16:44:34Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "6c02882a_8055e262",
      "tag": "autogenerated:trybots~happy",
      "revId": "d01e3ea68399a807f276143c8e0162e9f72e6bec",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7a646a32_98fd8bc6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 44008
      },
      "writtenOn": "2021-08-16T16:55:54Z",
      "side": 1,
      "message": "PTAL\n\nThe change now happens at the level of govulncheck, outside of audit.",
      "revId": "d01e3ea68399a807f276143c8e0162e9f72e6bec",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d1649ba_1ea2d516",
        "filename": "vulndb/govulncheck/main.go",
        "patchSetId": 4
      },
      "lineNbr": 174,
      "author": {
        "id": 12545
      },
      "writtenOn": "2021-08-17T16:57:19Z",
      "side": 1,
      "message": "I think we need to key this off the path and version (since a module can be imported at multiple versions), and the path should be replaced if the module has a replace directive. I think we can skip this additional map by switching modMap to\n\n modMap :\u003d map[string]*packages.Module{}\n \nand then building the module key with something like\n\n modKey :\u003d func(mod *packages.Module) string {\n   if mod.Replace !\u003d nil {\n     return fmt.Sprintf(\"%s@%s\", mod.Replace.Path, mod.Replace.Version)\n   }\n   return fmt.Sprintf(\"%s@%s\", mod.Path, mod.Version)\n }",
      "revId": "d01e3ea68399a807f276143c8e0162e9f72e6bec",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}