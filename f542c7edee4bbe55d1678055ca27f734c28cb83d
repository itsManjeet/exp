{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "7431f40a_9f1a8c63",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-08-16T17:56:03Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003df542c7ed",
      "tag": "autogenerated:trybots~beginning",
      "revId": "f542c7edee4bbe55d1678055ca27f734c28cb83d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "839c2676_9e3d0043",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2021-08-16T18:23:24Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "7431f40a_9f1a8c63",
      "tag": "autogenerated:trybots~happy",
      "revId": "f542c7edee4bbe55d1678055ca27f734c28cb83d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bdfbf8b4_49852e90",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 12545
      },
      "writtenOn": "2021-08-17T17:16:05Z",
      "side": 1,
      "message": "I believe the only case where a module can have an empty Version field is when it has been replaced using a replace directive that points to a directory on the local filesystem.\n\nSince we cannot know the version of the local module that is being used, the other option would be to assume all vulnerabilities match (which I believe is the current behavior?) Local replacements are not _super_ common, and I\u0027m not entirely convinced it makes sense to be extremely conservative in those cases.",
      "revId": "f542c7edee4bbe55d1678055ca27f734c28cb83d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "49048509_e45de274",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 44008
      },
      "writtenOn": "2021-08-17T17:27:48Z",
      "side": 1,
      "message": "\u003e I believe the only case where a module can have an empty Version field is when it has been replaced using a replace directive that points to a directory on the local filesystem.\n\u003e \n\u003e Since we cannot know the version of the local module that is being used, the other option would be to assume all vulnerabilities match (which I believe is the current behavior?) Local replacements are not _super_ common, and I\u0027m not entirely convinced it makes sense to be extremely conservative in those cases.\n\nThis was behavior before, but it is not anymore and that is correct IMO. Things are more clear now. That is, if we have a replace directive to a local dir, we would fetch vulnerabilities for that dir and that would return empty set of vulnerabilities. This makes a whole lot of sense since we really don\u0027t know what that local thing is. So, \"\" version here won\u0027t really matter.\n\nNote that top-level packages will also have \"\" version. In fact, this popped up. The database has entries for k8s.io/x and we run audit on k8s.io/x and we get a match because module version is \"\".\n\nIt seemed to me that the most general and cleanest way is to disregard \"\" version since we really don\u0027t know much about the module. The only exception is where a vulnerability applies to all versions.",
      "parentUuid": "bdfbf8b4_49852e90",
      "revId": "f542c7edee4bbe55d1678055ca27f734c28cb83d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "187aa79c_d2f91537",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 12545
      },
      "writtenOn": "2021-08-17T17:57:02Z",
      "side": 1,
      "message": "\u003e \u003e I believe the only case where a module can have an empty Version field is when it has been replaced using a replace directive that points to a directory on the local filesystem.\n\u003e \u003e \n\u003e \u003e Since we cannot know the version of the local module that is being used, the other option would be to assume all vulnerabilities match (which I believe is the current behavior?) Local replacements are not _super_ common, and I\u0027m not entirely convinced it makes sense to be extremely conservative in those cases.\n\u003e \n\u003e This was behavior before, but it is not anymore and that is correct IMO. Things are more clear now. That is, if we have a replace directive to a local dir, we would fetch vulnerabilities for that dir and that would return empty set of vulnerabilities. This makes a whole lot of sense since we really don\u0027t know what that local thing is. So, \"\" version here won\u0027t really matter.\n\nRe-reading the module listing code, my memory of how replace directives are represented was incorrect. When a local replace is done `Path` is the local filesystem path, rather than the canonical import path for the module that is being pointed at. In these cases we should be explicit skipping the inclusion of these modules in the extractModule function in govulncheck, since they aren\u0027t going to produce anything of value and will just result in pointless HTTP requests to the database. \n\n\u003e Note that top-level packages will also have \"\" version. In fact, this popped up. The database has entries for k8s.io/x and we run audit on k8s.io/x and we get a match because module version is \"\".\n\u003e \n\u003e It seemed to me that the most general and cleanest way is to disregard \"\" version since we really don\u0027t know much about the module. The only exception is where a vulnerability applies to all versions.\n\nFor top level modules I\u0027m fine being rather conservative for now, but we should look into deriving the module version, since we may have access to VCS metadata that can be used.",
      "parentUuid": "49048509_e45de274",
      "revId": "f542c7edee4bbe55d1678055ca27f734c28cb83d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a32106a1_5157d097",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 44008
      },
      "writtenOn": "2021-08-17T18:16:52Z",
      "side": 1,
      "message": "\u003e \u003e \u003e I believe the only case where a module can have an empty Version field is when it has been replaced using a replace directive that points to a directory on the local filesystem.\n\u003e \u003e \u003e \n\u003e \u003e \u003e Since we cannot know the version of the local module that is being used, the other option would be to assume all vulnerabilities match (which I believe is the current behavior?) Local replacements are not _super_ common, and I\u0027m not entirely convinced it makes sense to be extremely conservative in those cases.\n\u003e \u003e \n\u003e \u003e This was behavior before, but it is not anymore and that is correct IMO. Things are more clear now. That is, if we have a replace directive to a local dir, we would fetch vulnerabilities for that dir and that would return empty set of vulnerabilities. This makes a whole lot of sense since we really don\u0027t know what that local thing is. So, \"\" version here won\u0027t really matter.\n\u003e \n\u003e Re-reading the module listing code, my memory of how replace directives are represented was incorrect. When a local replace is done `Path` is the local filesystem path, rather than the canonical import path for the module that is being pointed at. In these cases we should be explicit skipping the inclusion of these modules in the extractModule function in govulncheck, since they aren\u0027t going to produce anything of value and will just result in pointless HTTP requests to the database. \n\u003e \n\nRight, but this seems to be a separate issue that concerns only reducing the number of db queries. In the end, the fetched vulnerabilities are empty.\n\n\u003e \u003e Note that top-level packages will also have \"\" version. In fact, this popped up. The database has entries for k8s.io/x and we run audit on k8s.io/x and we get a match because module version is \"\".\n\u003e \u003e \n\u003e \u003e It seemed to me that the most general and cleanest way is to disregard \"\" version since we really don\u0027t know much about the module. The only exception is where a vulnerability applies to all versions.\n\u003e \n\u003e For top level modules I\u0027m fine being rather conservative for now, but we should look into deriving the module version, since we may have access to VCS metadata that can be used.\n\nMy concern is for the cases where the VCS data might not be available. Two scenarios:\n\n1) k8s is not get getteable. One literally clones the code and works on it.\n2) Suppose one is working on a fix to an issue with a vulnerable function F in their project and the fix has not yet been published. Although the fix is currently in, one would still get reports for usages of F in the same project since the module version is \"\" and that matches the previous vulnerable versions of F that are now addressed.",
      "parentUuid": "187aa79c_d2f91537",
      "revId": "f542c7edee4bbe55d1678055ca27f734c28cb83d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1a991d8e_d8c5f952",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 12545
      },
      "writtenOn": "2021-08-17T20:29:10Z",
      "side": 1,
      "message": "Skipping modules replaced by local modules can be done in a follow-up change if you want.\n\n\u003e My concern is for the cases where the VCS data might not be available. Two scenarios:\n\nFor (1), in the case where a module was cloned then we inherently have VCS metadata, which is the underlying information the Go tooling uses for module versioning. It seems likely to incredibly uncommon for a user to retrieve a module and run govulncheck on it in such a way that there is absolutely no metadata (i.e. downloading the source in a zip or something).\n\nFor (2), I think it\u0027s perfectly reasonable to report those vulnerabilities if we are able to derive the version. The user of govulncheck would, presumably, know that they\u0027ve fixed the vulnerability that has been reported, and the reporting would indicate that the vulnerability database does not yet know about a fixed commit. The same thing would happen once they pushed a tagged version, since inherently there cannot be a \u0027fixed\u0027 entry in the vulndb at that point, and would only go away once the vulnerability database has been updated.\n\nFor cases where we cannot derive _any_ version information, it\u0027s perfectly reasonable to be rather conservative, although we may want to explicitly warn the user of the fact that we cannot provide proper vulnerability checking.\n\nLike I said initially though, I don\u0027t think this is something we need to worry about in this change. It\u0027s fine to add a todo/open an issue on the tracker to consider this work in the future.",
      "parentUuid": "a32106a1_5157d097",
      "revId": "f542c7edee4bbe55d1678055ca27f734c28cb83d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6ac8ea4e_192d1d55",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 44008
      },
      "writtenOn": "2021-08-17T21:12:26Z",
      "side": 1,
      "message": "Ok, lets go by accepting \"\" then as a valid version. My question is, how do we treat it? There seem to three options:\n\n1) Skip checking for such modules: we agreed to not do it.\n2) Let semver package take care of this: this is what is currently implemented. This will say that \"\" is not in the interval [v0.0.0 -] as evidenced by unit tests\n3) Say a vulnerability applies always for module with \"\" version.\n\nI am then in favor of 3). 2) seems to specific and not intuitive.",
      "parentUuid": "1a991d8e_d8c5f952",
      "revId": "f542c7edee4bbe55d1678055ca27f734c28cb83d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1effeb06_72c806b5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 12545
      },
      "writtenOn": "2021-08-18T16:22:16Z",
      "side": 1,
      "message": "(3) seems reasonable to me, with an explicit warning to the user that the version of the module is unknown, which is why it applies.",
      "parentUuid": "6ac8ea4e_192d1d55",
      "revId": "f542c7edee4bbe55d1678055ca27f734c28cb83d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}