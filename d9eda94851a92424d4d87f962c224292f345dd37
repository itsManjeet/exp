{
  "comments": [
    {
      "key": {
        "uuid": "0ddfa2f3_491ae5ff",
        "filename": "shiny/shiny.go",
        "patchSetId": 1
      },
      "lineNbr": 5,
      "author": {
        "id": 5015
      },
      "writtenOn": "2015-07-23T10:13:11Z",
      "side": 1,
      "message": "i don\u0027t believe this is what it does. it\u0027s one layer below what i would call a GUI.\n\nPackage shiny provides interfaces for portable two-dimensional graphics and event handling.",
      "range": {
        "startLine": 5,
        "startChar": 0,
        "endLine": 5,
        "endChar": 76
      },
      "revId": "d9eda94851a92424d4d87f962c224292f345dd37",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ddfa2f3_e91e39f1",
        "filename": "shiny/shiny.go",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 5015
      },
      "writtenOn": "2015-07-23T10:13:11Z",
      "side": 1,
      "message": "you should provide a paragraph overviewing the basic design.",
      "range": {
        "startLine": 7,
        "startChar": 0,
        "endLine": 7,
        "endChar": 2
      },
      "revId": "d9eda94851a92424d4d87f962c224292f345dd37",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8d92b264_0bb33d39",
        "filename": "shiny/shiny.go",
        "patchSetId": 1
      },
      "lineNbr": 27,
      "author": {
        "id": 6010
      },
      "writtenOn": "2015-07-24T01:15:39Z",
      "side": 1,
      "message": "What happens if you don\u0027t read this, or read it too slowly?\n\nGeneral thoughts:\n\nHaving built a couple of systems using channels for events like this I\u0027m not *entirely* sure that a channel is the right delivery mechanism. It *seems* to be right, and of course it makes it trivial to select on events from several different sources, but things become awkward when building GUI elements on top of it - for example, a widget might want to read a sequence of events from an event channel but only if the first event actually hits the widget. With a channel, you can\u0027t do that because you can\u0027t \"unread\" an event, so the final destination will miss out on the initial mouse-down event.\n\nBut perhaps that\u0027s something that should be left to a higher layer.\n\nFWIW I\u0027m wondering about something along the general lines of:\n\n    type Event interface {\n        Timestamp() time.Time\n    }\n\n    type Window interface {\n        // Events returns a source of events from the window.\n        // The EventSource must be closed when finished with.\n        // Only one EventSource from a given window\n        // may be in used at any one time.\n        Events() EventSource\n\n        // Send delivers an event to the window.\n        Send(Event)\n\n        // etc\n    }\n\n    // EventSource represents a source of UI events\n    // such as key presses and mouse clicks.\n    type EventSource interface {\n        // ReadEvent waits for the\n        // next event and then\n        // returns it.\n        ReadEvent() Event\n\n        // UnreadEvent puts the given event\n        // back in the event queue ready to be\n        // read again.\n        UnreadEvent(Event)\n\n        // Close closes the EventSource and causes\n        // a  blocked ReadEvent to unblock.\n        Close()\n    }\n\nEventSource might work better as a static type\n(EventQueue?) and of course you\u0027d want utility functions for turning an EventSource into a channel (not hard). I\u0027m not sure of the best way to abort a ReadEvent (for example on timeout).\n\nIt has been a few years since I thought about this - unfortunately I remember my conclusions much better than I remember my original reasons for thinking this might be a good idea :) I think it may have had to do with trying to come up with a decent design for higher-level event transformations (for example, some UI element might want to see \"long-click\" events), which proved hard to do with an event channel as the \"universal currency\" of events.",
      "range": {
        "startLine": 27,
        "startChar": 4,
        "endLine": 27,
        "endChar": 71
      },
      "revId": "d9eda94851a92424d4d87f962c224292f345dd37",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0db242f6_f7cd00a9",
        "filename": "shiny/shiny.go",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 6010
      },
      "writtenOn": "2015-07-24T01:15:39Z",
      "side": 1,
      "message": "Perhaps consider doing type Event interface{} or even having some common method defined on events (e.g. timestamp), so that the set of likely expected types is clear in code.",
      "range": {
        "startLine": 31,
        "startChar": 17,
        "endLine": 31,
        "endChar": 26
      },
      "revId": "d9eda94851a92424d4d87f962c224292f345dd37",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8dcab237_8e3f7b3f",
        "filename": "shiny/shiny.go",
        "patchSetId": 1
      },
      "lineNbr": 39,
      "author": {
        "id": 9165
      },
      "writtenOn": "2015-07-23T16:55:19Z",
      "side": 1,
      "message": "Should functions that take Buffer and Texture return error when the passed buffer is not compatible?",
      "revId": "d9eda94851a92424d4d87f962c224292f345dd37",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8dcab237_2ebe871f",
        "filename": "shiny/shiny.go",
        "patchSetId": 1
      },
      "lineNbr": 39,
      "author": {
        "id": 9165
      },
      "writtenOn": "2015-07-23T17:40:36Z",
      "side": 1,
      "message": "Maybe worth clarifying whether or not is allowed/expected for Textures and Buffers from a Window to be used in another Window (from the same implementation).",
      "parentUuid": "8dcab237_8e3f7b3f",
      "revId": "d9eda94851a92424d4d87f962c224292f345dd37",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8dcab237_2e1a07ff",
        "filename": "shiny/shiny.go",
        "patchSetId": 1
      },
      "lineNbr": 49,
      "author": {
        "id": 5030
      },
      "writtenOn": "2015-07-23T16:16:42Z",
      "side": 1,
      "message": "This is a convenience method, no? (You can Upload a buffer into a texture, and then Copy it onto the window.)\n\nAs such, how about making it a package function. By default it does the long path through an ephemeral texture, but it can look to see if the given window value implements a method like this, and use it as a fast path.\n\n(My motivation here is the Window type has a lot of methods, and I\u0027d like to shrink it if possible.)",
      "revId": "d9eda94851a92424d4d87f962c224292f345dd37",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8dcab237_0e15cbcd",
        "filename": "shiny/shiny.go",
        "patchSetId": 1
      },
      "lineNbr": 61,
      "author": {
        "id": 5030
      },
      "writtenOn": "2015-07-23T16:16:42Z",
      "side": 1,
      "message": "Is this motivated by X11 in some way? Because I don\u0027t understand tying these events to a window in terms of the underlying graphics systems on modern machines.\n\nA Texture represents a piece of graphics memory. Operations like Scale or Transform are done on or between pieces of graphics memory, so I would expect these to be methods on a texture.\n\nBesides the fact this doesn\u0027t fit with the way the underlying systems work, this is conceptually limiting. I would like to be able to upload a Buffer into a Texture, do transformations on it and then Download it. (The GPU has a couple of orders of magnitude on CPU implementations of Scale and Transform.) Forcing it onto the screen is limiting.",
      "revId": "d9eda94851a92424d4d87f962c224292f345dd37",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8dcab237_ae3cb74a",
        "filename": "shiny/shiny.go",
        "patchSetId": 1
      },
      "lineNbr": 61,
      "author": {
        "id": 9165
      },
      "writtenOn": "2015-07-23T16:55:19Z",
      "side": 1,
      "message": "My understanding is this is not limited to X11. At least on OpenGL those operations happen in a context (in this case a Window), i.e. you usually don\u0027t mutate a texture first and then render, but you render using the texture as input to the operations to render.",
      "parentUuid": "8dcab237_0e15cbcd",
      "revId": "d9eda94851a92424d4d87f962c224292f345dd37",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8dcab237_6edecf8e",
        "filename": "shiny/shiny.go",
        "patchSetId": 1
      },
      "lineNbr": 68,
      "author": {
        "id": 9165
      },
      "writtenOn": "2015-07-23T16:55:19Z",
      "side": 1,
      "message": "Would be worth to make Copy and Scale functions that use this one? Interface implementation internally could decide the most efficient way to do it based on the src2dst parameter.",
      "revId": "d9eda94851a92424d4d87f962c224292f345dd37",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8dcab237_6e6c8f7e",
        "filename": "shiny/shiny.go",
        "patchSetId": 1
      },
      "lineNbr": 87,
      "author": {
        "id": 5030
      },
      "writtenOn": "2015-07-23T16:16:42Z",
      "side": 1,
      "message": "Is this event running on the same paint queue as Upload, Copy, Scale, and Transform? Is it safe to write:\n\nw.Upload(..., buf, ...)\nbuf.Relase()\nw.EndPaint()\n\n?",
      "revId": "d9eda94851a92424d4d87f962c224292f345dd37",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ddfa2f3_091cddf6",
        "filename": "shiny/shiny.go",
        "patchSetId": 1
      },
      "lineNbr": 125,
      "author": {
        "id": 5015
      },
      "writtenOn": "2015-07-23T10:13:11Z",
      "side": 1,
      "message": "why not draw.Over? why do you need this?",
      "range": {
        "startLine": 125,
        "startChar": 7,
        "endLine": 125,
        "endChar": 8
      },
      "revId": "d9eda94851a92424d4d87f962c224292f345dd37",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8dcab237_ee1b9ffe",
        "filename": "shiny/shiny.go",
        "patchSetId": 1
      },
      "lineNbr": 125,
      "author": {
        "id": 5030
      },
      "writtenOn": "2015-07-23T16:16:42Z",
      "side": 1,
      "message": "Nigel may have other reasons, but would it be image/draw.Over or x/image/draw.Over?",
      "parentUuid": "0ddfa2f3_091cddf6",
      "range": {
        "startLine": 125,
        "startChar": 7,
        "endLine": 125,
        "endChar": 8
      },
      "revId": "d9eda94851a92424d4d87f962c224292f345dd37",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}