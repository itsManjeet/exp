// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

// This program generates the table keysymCodePoints from /usr/include/X11/keysymdef.h
package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"strconv"
	"strings"
)

func must(err error, reason string) {
	if err != nil {
		log.Fatalf("%s: %v", reason, err)
	}
}

func removeEmpty(v []string) []string {
	src, dst := 0, 0
	for src < len(v) {
		if v[src] != "" {
			v[dst] = v[src]
			dst++
		}
		src++
	}
	v = v[:dst]
	return v
}

func main() {
	fh, err := os.Open("/usr/include/X11/keysymdef.h")
	must(err, "opening keysymdef.h")
	defer fh.Close()

	seen := make(map[int64]struct{})

	buf := &bytes.Buffer{}

	fmt.Fprintf(buf, `// generated by go generate; DO NOT EDIT.

package x11key

// keysymCodePoints maps xproto.Keysym to their corresponding unicode code point.
var keysymCodePoints = map[rune]rune{
`)

	s := bufio.NewScanner(fh)
	for s.Scan() {
		line := strings.TrimSpace(s.Text())

		if !strings.HasPrefix(line, "#define XK_") {
			continue
		}

		line = strings.Replace(line, "/*(", "/* ", 1)
		line = strings.Replace(line, ")*/", " */", 1)

		v := removeEmpty(strings.Split(line, " "))

		if len(v) < 5 || !strings.HasPrefix(v[4], "U+") {
			continue
		}

		keysymVal, err := strconv.ParseInt(v[2], 0, 64)
		must(err, fmt.Sprintf("parsing input line %q", line))

		if _, isseen := seen[keysymVal]; isseen {
			continue
		}
		seen[keysymVal] = struct{}{}

		fmt.Fprintf(buf, "%#x: %s, // %s:\t%s\n", keysymVal, strings.Replace(v[4], "U+", "0x", 1), v[1], strings.Join(v[4:len(v)-1], " "))

	}
	must(s.Err(), "reading keysymdef.h")

	fmt.Fprintf(buf, "}\n")

	fmted, err := format.Source(buf.Bytes())
	must(err, "formatting output")

	must(ioutil.WriteFile("keysym_codepoints_table.go", fmted, 0644), "writing keysym_codepoints_table.go")
}
