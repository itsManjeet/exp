<!-- Autogenerated by weave; DO NOT EDIT -->
<!-- To regenerate the readme, run: -->
<!-- go run golang.org/x/example/gotypes@latest generic-go-types.md -->

# Updating tools to support type parameters.

This guide is maintained by Rob Findley (`rfindley@google.com`).

**status**: this document is currently a work-in-progress. See
[golang/go#50447](https://go.dev/issues/50447) for more details.

1. [Introduction](#introduction)
1. [Summary of new language features and their APIs](#summary-of-new-language-features-and-their-apis)
1. [Examples](#examples)
	1. [Generic types: type parameters](#generic-types:-type-parameters)
	1. [Constraint Interfaces](#constraint-interfaces)
	1. [Instantiation](#instantiation)
	1. [Generic types continued: method sets and predicates](#generic-types-continued:-method-sets-and-predicates)
1. [Updating tools while building at older Go versions](#updating-tools-while-building-at-older-go-versions)
1. [Further help](#further-help)

# Introduction

With Go 1.18, Go now supports generic programming via type parameters. This
document is intended to serve as a guide for tool authors that want to update
their tools to support the new language constructs introduced for generic Go.

This guide assumes some knowledge of the language changes to support generics.
See the following references for more information:

- The [original proposal](https://go.dev/issue/43651) for type parameters.
- The [addendum for type sets](https://go.dev/issue/45346).
- The [latest language specfication](https://tip.golang.org/ref/spec) (still in-progress as of 2021-01-11).
- The proposals for new APIs in
  [go/token and go/ast](https://go.dev/issue/47781), and in
  [go/types](https://go.dev/issue/47916).

It also assumes existing knowledge of `go/ast` and `go/types`. If you're just
getting started,
[x/example/gotypes](https://github.com/golang/example/tree/master/gotypes) is
a great introduction (and was the inspiration for this guide).

# Summary of new language features and their APIs

While generic Go programming is a large change to the language, at a high level
it introduces only a few new concepts. Specifically, we can break down our
discussion into the following three broad categories. In each category, the
relevant new APIs are listed (some constructors and getters/setters may be
elided where they are trivial).

**Generic types**. Types and functions may be _generic_, meaning their
declaration has a non-empty _type parameter list_: as in `type  List[T any]
...` or `func f[T1, T2 any]() { ... }`. Type parameter lists define placeholder
types (_type parameters_), scoped to the declaration, which may be substituted
by any type satisfying their corresponding _constraint interface_ to
_instantiate_ a new type or function.

Generic types may have methods, which declare `receiver type parameters` via
their receiver type expression: `func (r T[P1, ..., PN]) method(...) (...)
{...}`.

_New APIs_:
 - The field `ast.TypeSpec.TypeParams` holds the type parameter list syntax for
   type declarations.
 - The field `ast.FuncType.TypeParams` holds the type parameter list syntax for
   function declarations.
 - The type `types.TypeParam` is a `types.Type` representing a type parameter.
   On this type, the `Constraint` and `SetConstraint` methods allow
   getting/setting the constraint, the `Index` method returns the index of the
   type parameter in the type parameter list that declares it, and the `Obj`
   method returns the object declared in the declaration scope for the type
   parameter (a `types.TypeName`).
 - The type `types.TypeParamList` holds a list of type parameters.
 - The method `types.Named.TypeParams` returns the type parameters for a type
   declaration.
 - The method `types.Named.SetTypeParams` sets type parameters on a defined
   type.
 - The function `types.NewSignatureType` creates a new (possibly generic)
   signature type.
 - The method `types.Signature.RecvTypeParams` returns the receiver type
   parameters for a method.
 - The method `types.Signature.TypeParams` returns the type parameters for
   a function.

**Constraint Interfaces**: type parameter constraints are interfaces, expressed
via an interface type expression. Interfaces that are only used in constraint
position are permitted new embedded elements composed of tilde expressions
(`~T`) and unions (`A | B | ~C`). The new builtin interface type `comparable`
is implemented by types for which `==` and `!=` are valid. As a special case,
the `interface` keyword may be omitted from constraint expressions if it may be
implied (in which case we say the interface is _implicit_).

_New APIs_:
 - The constant `token.TILDE` is used to represent tilde expressions as an
   `ast.UnaryExpr`.
 - Union expressions are represented as an `ast.BinaryExpr` using `|`. This
   means that `ast.BinaryExpr` may now be both a type and value expression.
 - The method `types.Interface.IsImplicit` reports whether the `interface`
   keyword was elided from this interface.
 - The method `types.Interface.MarkImplicit` marks an interface as being
   implicit.
 - The method `types.Interface.IsComparable` reports whether every type in an
   interface's type set is comparable.
 - The method `types.Interface.IsMethodSet` reports whether an interface is
   defined entirely by its methods (has no _specific types_).
 - The type `types.Union` is a type that represents an embedded union
   expression in an interface. May only appear as an embedded element in
   interfaces.
 - The type `types.Term` represents a (possibly tilde) term of a union.

**Instantiation**: generic types and functions may be _instantiated_ to create
non-generic types and functions by providing _type arguments_ (`var x T[int]`).
Function type arguments may be _inferred_ via function arguments, or via
type parameter constraints.

_New APIs_:
 - The type `ast.IndexListExpr` holds index expressions with multiple indices,
   as occurs in instantiation expressions with multiple type arguments, or in
   receivers with multiple type parameters.
 - The function `types.Instantiate` instantiates a generic type with type arguments.
 - The type `types.Context` is an opaque instantiation context that may be
   shared to reduce duplicate instances.
 - The field `types.Config.Context` holds a shared `Context` to use for
   instantiation while type-checking.
 - The type `types.TypeList` holds a list of types.
 - The type `types.ArgumentError` holds an error associated with a specific
   argument index. Used to represent instantiation errors.
 - The field `types.Info.Instances` maps instantiated identifiers to information
   about the resulting type instance.
 - The type `types.Instance` holds information about a type or function
   instance.
 - The method `types.Named.TypeArgs` reports the type arguments used to
   instantiate a named type.

# Examples

The following examples demonstrate the new APIs above, and discuss their
properties. All examples are runnable, contained in subdirectories of the
directory holding this README.

## Generic types: type parameters

We say that a type is _generic_ if it has type parameters but no type arguments. This section explains how we can inspect generic types with the new `go/types` APIs.

### Type parameter lists

Suppose we want to understand the generic library below, which defines a generic
`Pair`, a constraint interface `Constraint`, and a generic function `MakePair`.

```
package main

type Constraint interface {
	Value() interface{}
}

type Pair[L, R any] struct {
	left  L
	right R
}

func MakePair[L, R Constraint](l L, r R) Pair[L, R] {
	return Pair[L, R]{l, r}
}
```

We can use the new `TypeParams` fields in `ast.TypeSpec` and `ast.FuncType` to
access the syntax of the type parameter list. From there, we can access type
parameter types in at least three ways:
 - by looking up type parameter definitions in `types.Info`
 - by calling `TypeParams()` on `types.Named` or `types.Signature`
 - by looking up type parameter objects in the declaration scope. Note that
   there now may be a scope associated with an `ast.TypeSpec` node.

```
func PrintTypeParams(fset *token.FileSet, file *ast.File) error {
	conf := types.Config{Importer: importer.Default()}
	info := &types.Info{
		Scopes: make(map[ast.Node]*types.Scope),
		Defs:   make(map[*ast.Ident]types.Object),
	}
	_, err := conf.Check("hello", fset, []*ast.File{file}, info)
	if err != nil {
		return err
	}

	// For convenience, we can use ast.Inspect to find the nodes we want to
	// investigate.
	ast.Inspect(file, func(n ast.Node) bool {
		var name *ast.Ident                  // the name of the generic object, or nil
		var tparamSyntax *ast.FieldList      // the list of type parameter fields
		var tparamTypes *types.TypeParamList // the list of type parameter types
		var scopeNode ast.Node               // the node associated with the declaration scope

		switch n := n.(type) {
		case *ast.TypeSpec:
			name = n.Name
			tparamSyntax = n.TypeParams
			tparamTypes = info.Defs[name].Type().(*types.Named).TypeParams()
			name = n.Name
			scopeNode = n
		case *ast.FuncDecl:
			name = n.Name
			tparamSyntax = n.Type.TypeParams
			tparamTypes = info.Defs[name].Type().(*types.Signature).TypeParams()
			scopeNode = n.Type
		}

		if name == nil {
			return true // not a generic object
		}

		// Option 1: find type parameters by looking at their declaring field list.
		if tparamSyntax != nil {
			fmt.Printf("%s has a type parameter field list with %d fields\n", name.Name, tparamSyntax.NumFields())
			for _, field := range tparamSyntax.List {
				for _, name := range field.Names {
					tparam := info.Defs[name]
					fmt.Printf("  field %s defines an object %q\n", name.Name, tparam)
				}
			}
		} else {
			fmt.Printf("%s does not have a type parameter list\n", name.Name)
		}

		// Option 2: find type parameters via the TypeParams() method on the
		// generic type.
		fmt.Printf("%s has %d type parameters:\n", name.Name, tparamTypes.Len())
		for i := 0; i < tparamTypes.Len(); i++ {
			tparam := tparamTypes.At(i)
			fmt.Printf("  %s has constraint %s\n", tparam, tparam.Constraint())
		}

		// Option 3: find type parameters by looking in the declaration scope.
		scope, ok := info.Scopes[scopeNode]
		if ok {
			fmt.Printf("%s has a scope with %d objects:\n", name.Name, scope.Len())
			for _, name := range scope.Names() {
				fmt.Printf("  %s is a %T\n", name, scope.Lookup(name))
			}
		} else {
			fmt.Printf("%s does not have a scope\n", name.Name)
		}

		return true
	})
	return nil
}
```

This program produces the following output. Note that not every type spec has
a scope.

```
> go run golang.org/x/tools/internal/typeparams/example/findtypeparams
Constraint does not have a type parameter list
Constraint has 0 type parameters:
Constraint does not have a scope
Pair has a type parameter field list with 2 fields
  field L defines an object "type parameter L any"
  field R defines an object "type parameter R any"
Pair has 2 type parameters:
  L has constraint any
  R has constraint any
Pair has a scope with 2 objects:
  L is a *types.TypeName
  R is a *types.TypeName
MakePair has a type parameter field list with 2 fields
  field L defines an object "type parameter L hello.Constraint"
  field R defines an object "type parameter R hello.Constraint"
MakePair has 2 type parameters:
  L has constraint hello.Constraint
  R has constraint hello.Constraint
MakePair has a scope with 4 objects:
  L is a *types.TypeName
  R is a *types.TypeName
  l is a *types.Var
  r is a *types.Var
```

## Constraint Interfaces

In order to allow operations on type parameters, Go 1.18 introduces the notion of [_type sets_](https://tip.golang.org/ref/spec#Interface_types), which is abstractly the set of types that implement an interface.

### New interface elements

Consider the generic library below:

```
package p

type Numeric interface{
	~int | ~float64 // etc...
}

func Square[N Numeric](n N) N {
	return n*n
}

type Findable interface {
	comparable
}

func Find[T Findable](s []T, v T) int {
	for i, v2 := range s {
		if v2 == v {
			return i
		}
	}
	return -1
}
```

In this library, we can see a few new features added in Go 1.18. The first is the new syntax in the `Numeric` type: unions of tilde-terms, specifying that the numeric type may only be satisfied by types whose underlying is `int` or `float64`.

The `go/ast` package parses this new syntax as a combination of unary and binary expressions, which we can see using the following program:

```
func PrintNumericSyntax(fset *token.FileSet, file *ast.File) {
	node := file.Scope.Lookup("Numeric").Decl.(*ast.TypeSpec)
	embedded := node.Type.(*ast.InterfaceType).Methods.List[0].Type
	ast.Print(fset, embedded)
}
```

Output:

```
     0  *ast.BinaryExpr {
     1  .  X: *ast.UnaryExpr {
     2  .  .  OpPos: p.go:6:2
     3  .  .  Op: ~
     4  .  .  X: *ast.Ident {
     5  .  .  .  NamePos: p.go:6:3
     6  .  .  .  Name: "int"
     7  .  .  }
     8  .  }
     9  .  OpPos: p.go:6:7
    10  .  Op: |
    11  .  Y: *ast.UnaryExpr {
    12  .  .  OpPos: p.go:6:9
    13  .  .  Op: ~
    14  .  .  X: *ast.Ident {
    15  .  .  .  NamePos: p.go:6:10
    16  .  .  .  Name: "float64"
    17  .  .  }
    18  .  }
    19  }
```

Once type-checked, these embedded expressions are represented using the new `types.Union` type, which flattens the expression into a list of terms. We can also investigate two new methods of interface: `Interface.IsComparable`, which reports whether the type set of an interface is comparable, and `Interface.IsMethodSet`, which reports whether an interface is expressable using methods alone.

```
func PrintInterfaceTypes(fset *token.FileSet, file *ast.File) error {
	conf := types.Config{}
	pkg, err := conf.Check("hello", fset, []*ast.File{file}, nil)
	if err != nil {
		return err
	}

	PrintIface(pkg, "Numeric")
	PrintIface(pkg, "Findable")

	return nil
}

func PrintIface(pkg *types.Package, name string) {
	obj := pkg.Scope().Lookup(name)
	fmt.Println(obj)
	iface := obj.Type().Underlying().(*types.Interface)
	for i := 0; i < iface.NumEmbeddeds(); i++ {
		fmt.Printf("\tembeded: %s\n", iface.EmbeddedType(i))
	}
	for i := 0; i < iface.NumMethods(); i++ {
		fmt.Printf("\tembeded: %s\n", iface.EmbeddedType(i))
	}
	fmt.Printf("\tIsComparable(): %t\n", iface.IsComparable())
	fmt.Printf("\tIsMethodSet(): %t\n", iface.IsMethodSet())
}
```

Output:

```
type hello.Numeric interface{~int|~float64}
        embeded: ~int|~float64
        IsComparable(): true
        IsMethodSet(): false
type hello.Findable interface{comparable}
        embeded: comparable
        IsComparable(): true
        IsMethodSet(): false
```

The `Findable` type demonstrates another new feature of Go 1.18: the comparable built-in. Comparable is a special interface type, not expressable using ordinary Go syntax, whose type-set consists of all comparable concrete types.

### Implicit interfaces

For interfaces that do not have methods, we can inline them in constraints and elide the `interface` keyword. In the example above, we could have done this for the `Square` function:

```
package p

func Square[N ~int|~float64](n N) N {
	return n*n
}
```

In such cases, the `Interface.IsImplicit` method reports whether the interface type was implicit. This is does not affect the behavior of the interface, but is captured for more accurate type strings:

```
func ShowImplicit(pkg *types.Package) {
	Square := pkg.Scope().Lookup("Square").Type().(*types.Signature)
	N := Square.TypeParams().At(0)
	constraint := N.Constraint().(*types.Interface)
	fmt.Println(constraint)
	fmt.Println("IsImplicit:", constraint.IsImplicit())
}
```

Output:

```
~int|~float64
IsImplicit: true
```

The `Interface.MarkImplicit` method is used to mark interfaces as implicit when importing.

### Type sets

The examples above demonstrate the new APIs for _accessing_ information about the new interface elements, but how do we understand [_type sets_](https://tip.golang.org/ref/spec#Interface_types), the new abstraction that these elements help define. Type sets may be arbitrarily complex, as in the following example:

```
package complex

type A interface{ ~string|~[]byte }

type B interface{ int|string }

type C interface { ~string|~int }

type D interface{ A|B; C }
```

In this example, the type set of `D` simplifies to `~string|int`, but the current `go/types` APIs do not expose this information. This will likely be added to `go/types` in future versions of Go, but in the meantime we can use the `typeparams.NormalTerms` helper:

```
func PrintNormalTerms(pkg *types.Package) error {
	D := pkg.Scope().Lookup("D").Type()
	terms, err := typeparams.NormalTerms(D)
	if err != nil {
		return err
	}
	for i, term := range terms {
		if i > 0 {
			fmt.Print("|")
		}
		fmt.Print(term)
	}
	fmt.Println()
	return nil
}
```

which outputs:

```
~string|int
```

See the documentation for `typeparams.NormalTerms` for more information on how this calculation proceeds.

## Instantiation

We say that a type is _instantiated_ if it is created from a generic type by substituting type arguments for type parameters.

### Finding instantiated types

Note that the receivers of method [Method] appear in the `Instances` map. This may be counterintuitive

More on this below
**TODO**

### Creating new instantiated types

**TODO**

### Using a shared context

**TODO**

## Generic types continued: method sets and predicates

Generic types are fundamentally different from ordinary types, in that they may not be used without instantiation. In some senses they are not really types: the go spec defines [types](https://tip.golang.org/ref/spec#Types) as "a set of values, together with operations and methods", but uninstantiated generic types do not define a set of values. Rather, they define a set of _types_. In that sense, they are a "meta type", or a "type template" (disclaimer: I am using these terms imprecisely).

However, for the purposes of `go/types` it is convenient to treat generic types as a `Type`. This section explains how generic types behave in existing `go/types` APIs.

### Method Sets

Methods on uninstantiated generic types are different from methods on an ordinary type. Consider that for an ordinary type `T`, the receiver base type of each method in its method set is `T`. However, this can't be the case for a generic type: generic types cannot be used without instantation, and so can't be the type of the receiver variable. Instead, the receiver base type is an _instantiated_ type, instantiated with the method's receiver type parameters.

This has some surprising consequences, which we observed in the section on instantiation above: for a generic type `G`, each of its methods will define a unique instantiation of `G`, as each method has distinct receiver type parameters.

To see this, consider the following example:

```
package p

type Pair[L, R any] struct {
	left  L
	right R
}

func (p Pair[L, _]) Left() L {
	return p.left
}

func (p Pair[_, R]) Right() R {
	return p.right
}

var IntPair Pair[int, int]
```

Let's inspect the method sets of the types in this library:

```
func PrintMethods(pkg *types.Package) {
	Pair := pkg.Scope().Lookup("Pair").Type().(*types.Named)
	IntPair := pkg.Scope().Lookup("IntPair").Type().(*types.Named)

	PrintMethodSet("Pair", Pair)
	PrintMethodSet("Pair[int, int]", IntPair)
	LeftObj, _, _ := types.LookupFieldOrMethod(Pair, false, pkg, "Left")
	LeftRecvType := LeftObj.Type().(*types.Signature).Recv().Type()
	PrintMethodSet("Pair[L, _]", LeftRecvType)
}

func PrintMethodSet(name string, typ types.Type) {
	fmt.Println(name + ":")
	methodSet := types.NewMethodSet(typ)
	for i := 0; i < methodSet.Len(); i++ {
		method := methodSet.At(i).Obj()
		fmt.Println(method)
	}
	fmt.Println()
}
```

Output:

```
Pair:
func (p.Pair[L, _]).Left() L
func (p.Pair[_, R]).Right() R

Pair[int, int]:
func (p.Pair[int, int]).Left() int
func (p.Pair[int, int]).Right() int

Pair[L, _]:
func (p.Pair[L, _]).Left() L
func (p.Pair[L, _]).Right() _
```

In this example, we can see that all of `Pair`, `Pair[int, int]`, and `Pair[L, _]` have distinct method sets, though the method set of `Pair` and `Pair[L, _]` intersect in the `Left` method.

Only the objects in `Pair`'s method set are recorded in `types.Info.Defs`. To get back to this "canonical" method object, the `typeparams` package provides the `OriginMethod` helper:

```
func CompareOrigins(pkg *types.Package) {
	Pair := pkg.Scope().Lookup("Pair").Type().(*types.Named)
	IntPair := pkg.Scope().Lookup("IntPair").Type().(*types.Named)
	Left, _, _ := types.LookupFieldOrMethod(Pair, false, pkg, "Left")
	LeftInt, _, _ := types.LookupFieldOrMethod(IntPair, false, pkg, "Left")

	fmt.Println("Pair.Left == Pair[int, int].Left:", Left == LeftInt)
	origin := typeparams.OriginMethod(LeftInt.(*types.Func))
	fmt.Println("Pair.Left == OriginMethod(Pair[int, int].Left):", Left == origin)
}
```

Output:

```
Pair.Left == Pair[int, int].Left: false
Pair.Left == OriginMethod(Pair[int, int].Left): true
```

### Predicates

Predicates on generic types are not defined by the spec. For example, it is not clear what `AssignableTo` means with respect to a generic type.

The behavior of predicates on generic `Named` types may generally be derived from the fact that: type parameters bound to different names are different types. This means that most predicates involving generic types will return "false".

`Signature` types are treated differently. Similar to ordinary signature
parameters, signature identity is considered "modulo renaming": two generic
signatures are identical if they are identical modulo type parameter renaming.

Consider the following code:

```
func OrdinaryPredicates(pkg *types.Package) {
	var (
		Pair        = pkg.Scope().Lookup("Pair").Type()
		LeftRighter = pkg.Scope().Lookup("LeftRighter").Type()
		Mer         = pkg.Scope().Lookup("Mer").Type()
		F           = pkg.Scope().Lookup("F").Type()
		G           = pkg.Scope().Lookup("G").Type()
		H           = pkg.Scope().Lookup("H").Type()
	)

	fmt.Println("AssignableTo(Pair, LeftRighter)", types.AssignableTo(Pair, LeftRighter))
	fmt.Println("AssignableTo(Pair, Mer): ", types.AssignableTo(Pair, Mer))
	fmt.Println("Identical(F, G)", types.Identical(F, G))
	fmt.Println("Identical(F, H)", types.Identical(F, H))
}
```

Output:

```
AssignableTo(Pair, LeftRighter) false
AssignableTo(Pair, Mer):  true
Identical(F, G) true
Identical(F, H) false
```

In this example, we see that despite their similarity the generic `Pair` type is not assignable to the generic `LeftRighter` type. We also see the rules for signature identity in practice.

This begs the question: how does one ask questions about the relationship between generic types. In general, in order to phrase these questions we need more information: how does one relate the type parameters of `Pair` to the type parameters of `LeftRighter`? Does it suffice for the predicate to hold for one element of the type sets, or must it hold for all elements of the type sets?

We can use instantiation to answer some of these questions. In particular, by instantiating both `Pair` and `LeftRighter` with the type parameters of `Pair`, we can determing if, for all type arguments `[X, Y]` that are valid for `Pair`, `[X, Y]` are also valid type arguments of `LeftRighter`, and `Pair[X, Y]` is assignable to `LeftRighter[X, Y]`. The `typeparams.GenericAssignableTo` implements exactly this predicate:

```
func GenericPredicates(pkg *types.Package) {
	var (
		Pair        = pkg.Scope().Lookup("Pair").Type()
		LeftRighter = pkg.Scope().Lookup("LeftRighter").Type()
	)
	fmt.Println("GenericAssignableTo(Pair, LeftRighter)", typeparams.GenericAssignableTo(nil, Pair, LeftRighter))
}
```

Output:

```
GenericAssignableTo(Pair, LeftRighter) true
```

# Updating tools while building at older Go versions

In the examples above, we can see how a lot of the new APIs integrate with
existing usage of `go/ast` or `go/types`. However, most tools still need to
build at older Go versions, and handling the new language constructs in-line
will break builds at older Go versions.

For this purpose, the `x/exp/typeparams` package provides functions and types
that proxy the new APIs (with stub implementations at older Go versions).
**NOTE**: does not yet exist -- see
[golang/go#50447](https://go.dev/issues/50447) for more information.

# Further help

If you're working on updating a tool to support generics, and need help, please
feel free to reach out for help in any of the following ways:
 - Via the [golang-tools](https://groups.google.com/g/golang-tools) mailing list.
 - Directly to me via email (`rfindley@google.com`).
 - For bugs, you can [file an issue](https://github.com/golang/go/issues/new/choose).
