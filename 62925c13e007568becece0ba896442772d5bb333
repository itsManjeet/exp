{
  "comments": [
    {
      "key": {
        "uuid": "64bbdda0_6a42376a",
        "filename": "shiny/font/font.go",
        "patchSetId": 5
      },
      "lineNbr": 47,
      "author": {
        "id": 5761
      },
      "writtenOn": "2015-08-12T15:53:52Z",
      "side": 1,
      "message": "Making Glyph a render-specific method means that this interface will need additional methods to provide glyph metrics. I worry that it will get quite large. What about encapsulating Glyphs in a type and returning that type here. I am thinking about something like:\n\n// A Glyph allows access to glyph-specific metrics and rendering.\ntype Glyph interface {\n\tAdvance() fixed.Int26_6\n\tHeight() fixed.Int26_6\n\tWidth() fixed.Int26_6\n\t// At returns the rendering of the glyph at the sub-pixel destination dot.\n\t// The user can get the new dot by doing dot+g.Advance().\n\tAt(dot fixed.Point26_6) (dr image.Rectangle, mask image.Image, maskp image.Point)\n}\n\ntype Face interface {\n\t…\n\n\t// Glyph returns the Glyph in this face corresponding to the rune r, or nil if the face has no such glyph.\n\tGlyph(r rune) Glyph\n\n\t// Kern returns …\n\t// If the two Glyphs are not from the same Face, Kern returns 0.\n\t// (Kern could use glyph.index [see below], for example, to more quickly locate kerning info.)\n\tKern(g0, g1 Glyph) fixed.Int26_6\n}\n\n// Now in truetype.go\n\npackage truetype\n\ntype glyph strurct {\n\tadv, height, width fixed.Int26_6\n\tindex truetype.Index // For example\n\tfont Face // Perhaps\n}",
      "range": {
        "startLine": 46,
        "startChar": 36,
        "endLine": 47,
        "endChar": 91
      },
      "revId": "62925c13e007568becece0ba896442772d5bb333",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "24dc85fc_f62b7831",
        "filename": "shiny/font/font.go",
        "patchSetId": 5
      },
      "lineNbr": 47,
      "author": {
        "id": 5899
      },
      "writtenOn": "2015-08-14T12:50:04Z",
      "side": 1,
      "message": "Having Glyph-the-method return a Glyph-the-interface will probably mean that every call to Glyph-the-method will allocate. I\u0027d like to be able to render a paragraph of text without any allocations, in the steady state.\n\nYou might be able to re-use some backing storage, but then it gets tricky when you have to keep multiple Glyph-the-interface values around for e.g. kerning.",
      "parentUuid": "64bbdda0_6a42376a",
      "range": {
        "startLine": 46,
        "startChar": 36,
        "endLine": 47,
        "endChar": 91
      },
      "revId": "62925c13e007568becece0ba896442772d5bb333",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0456a145_775110e0",
        "filename": "shiny/font/font.go",
        "patchSetId": 5
      },
      "lineNbr": 47,
      "author": {
        "id": 5761
      },
      "writtenOn": "2015-08-14T13:11:54Z",
      "side": 1,
      "message": "Probably true, but one of my concerns is that this interface will tightly couple glyph layout with glyph drawing. Given a fixed-width text area, you need to compute which glyphs fit on a line. Additionally, you don\u0027t want to render lines of text that are unchanged. One approach is to first layout the glyphs into lines, and then separately render the lines. This way, it\u0027s easy to check which lines are unchanged after the layout. Unchanged lines needn\u0027t be rendered, you can simply use their previously cached texture. However, if the way to layout glyphs is to call this method and test whether newDot goes beyond the text area width, then you lose the benefit of caching the rendering, because you must render in order to compute the lines in the first place.\n\nI have an implementation of the two step, layout-then-render, approach here: https://github.com/eaburns/T/tree/gui/gui. It\u0027s just an experiment, so it may not be very pretty, but maybe it\u0027s of interest. You can try it out by building the program in the \u0027play\u0027 directory.\n\nBy the way, if the Glyph interface doesn\u0027t escape, need it still allocate?",
      "parentUuid": "24dc85fc_f62b7831",
      "range": {
        "startLine": 46,
        "startChar": 36,
        "endLine": 47,
        "endChar": 91
      },
      "revId": "62925c13e007568becece0ba896442772d5bb333",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c4dac934_7d7d5756",
        "filename": "shiny/font/font.go",
        "patchSetId": 5
      },
      "lineNbr": 47,
      "author": {
        "id": 5899
      },
      "writtenOn": "2015-08-17T02:09:12Z",
      "side": 1,
      "message": "Measuring glyphs without generating the mask images will be a separate method, so that glyph layout and glyph drawing are not tightly coupled. It\u0027s the \"TODO: per-font and per-glyph Metrics\".\n\nAs for your experimental code, it imports \"github.com/eaburns/T/font\" but I can\u0027t seem to find that package.\n\nAs for allocation, if you return a Glyph-the-interface, then the return value escapes Glyph-the-method. See also http://research.swtch.com/interfaces",
      "parentUuid": "0456a145_775110e0",
      "range": {
        "startLine": 46,
        "startChar": 36,
        "endLine": 47,
        "endChar": 91
      },
      "revId": "62925c13e007568becece0ba896442772d5bb333",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}