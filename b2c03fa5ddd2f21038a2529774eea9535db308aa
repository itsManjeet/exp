{
  "comments": [
    {
      "key": {
        "uuid": "9bcc2f8c_4fdc0919",
        "filename": "write/write.go",
        "patchSetId": 2
      },
      "lineNbr": 16,
      "author": {
        "id": 6365
      },
      "writtenOn": "2018-04-16T22:42:22Z",
      "side": 1,
      "message": "Do we need to verify that tmpdir is on the same file system as dest?\n\n(Would it make sense to fall back to `filepath.Dir(dest)` if $TMPDIR isn\u0027t on the same file system?)",
      "revId": "b2c03fa5ddd2f21038a2529774eea9535db308aa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "50635ef6_6b7e38ce",
        "filename": "write/write.go",
        "patchSetId": 2
      },
      "lineNbr": 16,
      "author": {
        "id": 8470
      },
      "writtenOn": "2018-06-28T10:59:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9bcc2f8c_4fdc0919",
      "revId": "b2c03fa5ddd2f21038a2529774eea9535db308aa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a0a6d332_e6e0ed6c",
        "filename": "write/write.go",
        "patchSetId": 2
      },
      "lineNbr": 22,
      "author": {
        "id": 6365
      },
      "writtenOn": "2018-04-16T22:42:22Z",
      "side": 1,
      "message": "This seems fragile from an API perspective.\n\nThere are many reasons one might want to use the write-and-rename strategy, including:\n• Ensuring that incomplete files don\u0027t have the exact names of their complete equivalents.\n• Ensuring that incomplete files don\u0027t match globs.\n• Ensuring that temporary files go into a directory that is periodically cleaned by some other means (e.g., a cron job).\n\nThis API addresses the first only.\nThe second requires that the temporary directory is not `filepath.Dir(dest)`.\nThe third requires application control over the temporary directory.",
      "revId": "b2c03fa5ddd2f21038a2529774eea9535db308aa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3c65f7f7_e915d759",
        "filename": "write/write.go",
        "patchSetId": 2
      },
      "lineNbr": 22,
      "author": {
        "id": 8470
      },
      "writtenOn": "2018-06-28T10:59:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a0a6d332_e6e0ed6c",
      "revId": "b2c03fa5ddd2f21038a2529774eea9535db308aa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "353dd69b_05e5e560",
        "filename": "write/write.go",
        "patchSetId": 2
      },
      "lineNbr": 58,
      "author": {
        "id": 6365
      },
      "writtenOn": "2018-04-16T22:42:22Z",
      "side": 1,
      "message": "This seems to conflate recovery and reporting. (It may be useful to return the error to the caller for logging/reporting/monitoring even if there is nothing more they can do to recover from that error.)",
      "range": {
        "startLine": 57,
        "startChar": 54,
        "endLine": 58,
        "endChar": 37
      },
      "revId": "b2c03fa5ddd2f21038a2529774eea9535db308aa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "455189ab_24f25102",
        "filename": "write/write.go",
        "patchSetId": 2
      },
      "lineNbr": 58,
      "author": {
        "id": 8470
      },
      "writtenOn": "2018-06-28T10:59:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "353dd69b_05e5e560",
      "range": {
        "startLine": 57,
        "startChar": 54,
        "endLine": 58,
        "endChar": 37
      },
      "revId": "b2c03fa5ddd2f21038a2529774eea9535db308aa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "41bdaa1e_cf942df9",
        "filename": "write/write.go",
        "patchSetId": 2
      },
      "lineNbr": 59,
      "author": {
        "id": 6365
      },
      "writtenOn": "2018-04-16T22:42:22Z",
      "side": 1,
      "message": "This currently results in a double-Close if the Close call in CloseAtomicallyReplace fails.\n\n(Some io.Closer implementations do not allow Close to be called more than once, and (*file.File).Close does not currently say one way or the other.)",
      "revId": "b2c03fa5ddd2f21038a2529774eea9535db308aa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e4d89156_911c688a",
        "filename": "write/write.go",
        "patchSetId": 2
      },
      "lineNbr": 59,
      "author": {
        "id": 8470
      },
      "writtenOn": "2018-06-28T10:59:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "41bdaa1e_cf942df9",
      "revId": "b2c03fa5ddd2f21038a2529774eea9535db308aa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bb711e48_9a5e00ce",
        "filename": "write/write.go",
        "patchSetId": 2
      },
      "lineNbr": 68,
      "author": {
        "id": 5167
      },
      "writtenOn": "2018-04-17T18:55:04Z",
      "side": 1,
      "message": "This doesn\u0027t seem like something we can ask of the caller. If this package isn\u0027t taking care of such details, then what\u0027s the point?\n\nThat said, I agree with the distinction you\u0027re drawing between atomicity and durability, since there are applications where you care only that the file either exist or not exist after a crash, and there are applications where you need to ensure that it exists before doing a follow-on action, even if there\u0027s a crash. In particular, I think this comes up in applications that need to write several files and can atomically commit each individual file, but need a group durability guarantee only once all of the files have been written. This can usually be implemented in a far more performant way than durably committing each individual file.\n\nBut the API of this package should directly expose the concepts of atomicity and durability and implement them however\u0027s appropriate, rather than depending on the caller to determine whether the file system uses write barriers.",
      "revId": "b2c03fa5ddd2f21038a2529774eea9535db308aa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "521b73b5_bda33293",
        "filename": "write/write.go",
        "patchSetId": 2
      },
      "lineNbr": 68,
      "author": {
        "id": 8470
      },
      "writtenOn": "2018-06-28T10:59:08Z",
      "side": 1,
      "message": "Done (see my comment on the proposal at https://github.com/golang/go/issues/22397)",
      "parentUuid": "bb711e48_9a5e00ce",
      "revId": "b2c03fa5ddd2f21038a2529774eea9535db308aa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "84bda188_77fcdc65",
        "filename": "write/write.go",
        "patchSetId": 2
      },
      "lineNbr": 71,
      "author": {
        "id": 6365
      },
      "writtenOn": "2018-04-16T22:42:22Z",
      "side": 1,
      "message": "I understand the reason behind the naming, but I can\u0027t say I\u0027m a fan. (It\u0027s already verbose, but missing a conjunction.)\n\nI\u0027d be inclined to call this method `Commit` or `Rename` instead.",
      "range": {
        "startLine": 71,
        "startChar": 22,
        "endLine": 71,
        "endChar": 44
      },
      "revId": "b2c03fa5ddd2f21038a2529774eea9535db308aa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "38feef29_d7d31d4a",
        "filename": "write/write.go",
        "patchSetId": 2
      },
      "lineNbr": 71,
      "author": {
        "id": 8470
      },
      "writtenOn": "2018-06-28T10:59:08Z",
      "side": 1,
      "message": "I don’t have very strong feelings, but I wonder if Commit or Rename are really better choices. Commit might imply durability to casual readers, which we don’t guarantee. Rename doesn’t convey that the file is closed after this call.\n\nDo we put conjunctions in method names as a general rule? We don’t have them in e.g. io.WriteSeeker.",
      "parentUuid": "84bda188_77fcdc65",
      "range": {
        "startLine": 71,
        "startChar": 22,
        "endLine": 71,
        "endChar": 44
      },
      "revId": "b2c03fa5ddd2f21038a2529774eea9535db308aa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0898f730_6b748c6e",
        "filename": "write/write.go",
        "patchSetId": 2
      },
      "lineNbr": 82,
      "author": {
        "id": 5167
      },
      "writtenOn": "2018-04-17T18:55:04Z",
      "side": 1,
      "message": "This is the main entry point to this package, yet it seems like *temporary* files are the least likely files to require atomic commit. And they certainly don\u0027t require durability, given that /tmp is often scrubbed on reboot.",
      "revId": "b2c03fa5ddd2f21038a2529774eea9535db308aa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5135f41c_2b4a2aa7",
        "filename": "write/write.go",
        "patchSetId": 2
      },
      "lineNbr": 82,
      "author": {
        "id": 8470
      },
      "writtenOn": "2018-06-28T10:59:08Z",
      "side": 1,
      "message": "The way to atomically write a file is to create a temporary file, then rename it. The names in this package reflect that. We’re not just talking about creating a temporary file, but a temporary file with the intention of atomically making it appear at the destination path.",
      "parentUuid": "0898f730_6b748c6e",
      "revId": "b2c03fa5ddd2f21038a2529774eea9535db308aa",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}