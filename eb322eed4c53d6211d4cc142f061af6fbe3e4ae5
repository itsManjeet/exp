{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "63a311e0_3a2324d6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-09-28T12:19:52Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003deb322eed\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "eb322eed4c53d6211d4cc142f061af6fbe3e4ae5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0cc7a4d6_871e5916",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-09-28T12:21:42Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "63a311e0_3a2324d6",
      "tag": "autogenerated:trybots~happy",
      "revId": "eb322eed4c53d6211d4cc142f061af6fbe3e4ae5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "134a2a10_2dcbb704",
        "filename": "slog/level.go",
        "patchSetId": 2
      },
      "lineNbr": 114,
      "author": {
        "id": 57259
      },
      "writtenOn": "2022-09-28T15:07:47Z",
      "side": 1,
      "message": "I still think this obfuscates rather than clarifies. Why would I use a Level versus an *AtomicLevel? Answer: because it is not safe to update the options.Level field once the options are already in use. (It is sorta safe---a benign data race---so long as you only update the field with a new value of the same runtime type.) So, use a Level when you plan to set it once at HandlerOptions construction and never change it again. Or, use an AtomicLevel when you need to be able to change the Level value after it is in use---but still you must never change the options.Level field itself again. But, you might ask, why not just expose atomic operations on a private field in the options struct? Ah, because it\u0027s inconvenient to construct, and you might need to share a single level variable between multiple options. Why not use an AtomicLevel, always? Are we perhaps trying to avoid the cost of atomics accesses? But in doing so we\u0027re paying for dynamic calls.\n\nThis all seems quite complicated and the motivation is still not clear to me.",
      "revId": "eb322eed4c53d6211d4cc142f061af6fbe3e4ae5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}