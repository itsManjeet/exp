{
  "comments": [
    {
      "key": {
        "uuid": "7ba54fc6_dfdcbb98",
        "filename": "shiny/driver/gldriver/window.go",
        "patchSetId": 1
      },
      "lineNbr": 72,
      "author": {
        "id": 5899
      },
      "writtenOn": "2015-11-23T09:18:22Z",
      "side": 1,
      "message": "It seems the wrong way round for a Release call to trigger a lifecycle.StageDead event. Instead, the flow I imagine is:\n\n1. user clicks on the \"x\" to close the window.\n2. the OS / window system sends an OS / WS specific message.\n3. the Shiny driver recognizes this, just like it recognizes other window lifecycle changes such as gaining or losing visibility, and sends a lifecycle.StageDead to the app code (\"package main\").\n4. the app code breaks out of the loop, via a \"return\".\n5. a \"defer w.Release()\" fires.",
      "revId": "1bfc2a1ec83b85ddc8aecd1cf33d2fc00b5c961d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fb0f7f76_89363d8f",
        "filename": "shiny/driver/gldriver/window.go",
        "patchSetId": 1
      },
      "lineNbr": 72,
      "author": {
        "id": 5030
      },
      "writtenOn": "2015-11-25T12:49:24Z",
      "side": 1,
      "message": "This code supports that exact flow.\n\n1. user clicks \"x\", which calls cocoa\u0027s windowWillClose.\n2. windowWillClose calls windowClosing, which calls releaseCleanup\n3. releaeCleanup sends lifecycle.StageDead\n4. app code breaks out of the loop.\n5. a \"defer w.Release()\" fires, which calls performClose which is now a no-op because the window has already closed.\n\n(There were however two other bugs to do with StageDead fixed in the current patchset.)\n\nFor completeness, there is also an alternate flow here, described above:\n\n1. The program wants to close a window. It calls w.Release().\n2. Cocoa is informed, and eventually sends a lifecycle.StageDead, which hopefully is ignored by the program who should have given up on events when it decided to close the window.\n\nI think it\u0027s only the x11driver that has the problem you describe, which I fixed.",
      "parentUuid": "7ba54fc6_dfdcbb98",
      "revId": "1bfc2a1ec83b85ddc8aecd1cf33d2fc00b5c961d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7ba54fc6_13d69ce9",
        "filename": "shiny/driver/gldriver/window.go",
        "patchSetId": 1
      },
      "lineNbr": 72,
      "author": {
        "id": 5899
      },
      "writtenOn": "2015-11-27T01:01:16Z",
      "side": 1,
      "message": "Ah, I might have been thrown off because the method name here says \"release\".\n\nIn any case, I\u0027m still not totally convinced that this (and especially the matching golang.org/cl/17054) feels right. I\u0027d like to do some thinking and experimentation myself, not just about this but also about accruing multiple pending paint.Events (which you mention in cl/17054), but I don\u0027t have the time to do that in the immediate term.",
      "parentUuid": "fb0f7f76_89363d8f",
      "revId": "1bfc2a1ec83b85ddc8aecd1cf33d2fc00b5c961d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fb0f7f76_57e5fcca",
        "filename": "shiny/driver/gldriver/window.go",
        "patchSetId": 1
      },
      "lineNbr": 72,
      "author": {
        "id": 5030
      },
      "writtenOn": "2015-11-30T19:44:15Z",
      "side": 1,
      "message": "Sure, I\u0027m not in a rush on this. For when you\u0027re thinking about this, a note on how I got here:\n\nThe most interesting part of a NextEvent method to me is being able to align the state of other methods on the Window with the current event the user\u0027s program is handling.\n\nThere is a way to do this with the current interface and a more complex implementation. It turned out to be complex enough that I decided to propose a NextEvent method instead, but for completion:\n\ntype windowImpl struct {\n        pump pump.Pump\n\n        events chan interface{}\n        state     chan interface{}\n}\n\nfunc createWindow() Window {\n        w :\u003d \u0026windowImpl{\n                pump: ... // infinite buffer\n\n                // unbuffered channels\n                events: make(chan interface{}),\n                state: make(chan interface{}),\n        }\n        go w.maintainState()\n}\n\nfunc (w *windowImpl) Events() \u003c-chan interface{} {\n        return w.events\n}\n\nfunc (w *windowImpl) SomeState() interface{} {\n        return \u003c-w.state\n}\n\nfunc (w *windowImpl) maintainState() {\n        var state interface{}\nLoop1:\n        for {\n                var next interface{}\n                select {\n                case next, _ \u003d \u003c-w.pump.Out:\n                case w.state \u003c- state:\n                        continue\n                }\n\n                for {\n                        select {\n                        case w.events \u003c- next:\n                                state \u003d updateState(next)\n                                continue Loop1\n                        case w.state \u003c- state:\n                        }\n                }\n        }\n}\n\nBy making a little state machine sitting directly behind an unbuffered Events channel, that is also responsible for serving up SomeState, the SomeState can promise to be up to date with the latest event that was returned.\n\nA goroutine can probably be saved by merging in the implementation of pump.Pump, but I find this conceptually pretty tricky in this trivial SomeState example. If there was more than one stateful method it would get unruly.",
      "parentUuid": "7ba54fc6_13d69ce9",
      "revId": "1bfc2a1ec83b85ddc8aecd1cf33d2fc00b5c961d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7ba54fc6_9fe63367",
        "filename": "shiny/driver/x11driver/window.go",
        "patchSetId": 1
      },
      "lineNbr": 64,
      "author": {
        "id": 5899
      },
      "writtenOn": "2015-11-23T09:18:22Z",
      "side": 1,
      "message": "Ditto.",
      "revId": "1bfc2a1ec83b85ddc8aecd1cf33d2fc00b5c961d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fb0f7f76_e94371ef",
        "filename": "shiny/driver/x11driver/window.go",
        "patchSetId": 1
      },
      "lineNbr": 64,
      "author": {
        "id": 5030
      },
      "writtenOn": "2015-11-25T12:49:24Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7ba54fc6_9fe63367",
      "revId": "1bfc2a1ec83b85ddc8aecd1cf33d2fc00b5c961d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7ba54fc6_5f842b79",
        "filename": "shiny/example/goban/main.go",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 5899
      },
      "writtenOn": "2015-11-23T09:18:22Z",
      "side": 1,
      "message": "You probably want to catch lifecycle events here (and specifically lifecycle.StageDead) too.",
      "revId": "1bfc2a1ec83b85ddc8aecd1cf33d2fc00b5c961d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fb0f7f76_c94035e6",
        "filename": "shiny/example/goban/main.go",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 5030
      },
      "writtenOn": "2015-11-25T12:49:24Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7ba54fc6_5f842b79",
      "revId": "1bfc2a1ec83b85ddc8aecd1cf33d2fc00b5c961d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7ba54fc6_1f7ea345",
        "filename": "shiny/example/tile/main.go",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 5899
      },
      "writtenOn": "2015-11-23T09:18:22Z",
      "side": 1,
      "message": "Ditto.",
      "range": {
        "startLine": 53,
        "startChar": 15,
        "endLine": 53,
        "endChar": 16
      },
      "revId": "1bfc2a1ec83b85ddc8aecd1cf33d2fc00b5c961d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fb0f7f76_294f4914",
        "filename": "shiny/example/tile/main.go",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 5030
      },
      "writtenOn": "2015-11-25T12:49:24Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7ba54fc6_1f7ea345",
      "range": {
        "startLine": 53,
        "startChar": 15,
        "endLine": 53,
        "endChar": 16
      },
      "revId": "1bfc2a1ec83b85ddc8aecd1cf33d2fc00b5c961d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}