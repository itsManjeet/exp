{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "702036c4_9585f7e5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-09-07T11:26:57Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003d879802f5\n",
      "tag": "autogenerated:trybots~beginning",
      "revId": "879802f5a57eddfb8ce2baaa61055e5ab3eb301d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5104fc08_a154e63b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-09-07T11:26:57Z",
      "side": 1,
      "message": "Superseded.",
      "parentUuid": "952e968b_b9e096b8",
      "tag": "autogenerated:trybots~beginning",
      "revId": "879802f5a57eddfb8ce2baaa61055e5ab3eb301d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9ce77e7b_19f4e954",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-09-07T11:28:01Z",
      "side": 1,
      "message": "Build is still in progress... Status page: https://farmer.golang.org/try?commit\u003d879802f5\nFailed on linux-amd64: https://storage.googleapis.com/go-build-log/ed530dbd/linux-amd64_b03bec90.log\nOther builds still in progress; subsequent failure notices suppressed until final report.\n\nConsult https://build.golang.org/ to see whether they are new failures. Keep in mind that TryBots currently test *exactly* your git commit, without rebasing. If your commit\u0027s git parent is old, the failure might\u0027ve already been fixed.\n",
      "parentUuid": "702036c4_9585f7e5",
      "tag": "autogenerated:trybots~progress",
      "revId": "879802f5a57eddfb8ce2baaa61055e5ab3eb301d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "13b8399c_d0043631",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-09-07T11:29:42Z",
      "side": 1,
      "message": "4 of 4 TryBots failed.\nFailed on linux-amd64: https://storage.googleapis.com/go-build-log/ed530dbd/linux-amd64_b03bec90.log\nFailed on linux-amd64-race: https://storage.googleapis.com/go-build-log/ed530dbd/linux-amd64-race_078abded.log\nFailed on windows-amd64-2016: https://storage.googleapis.com/go-build-log/ed530dbd/windows-amd64-2016_73d4047c.log\nFailed on windows-386-2008: https://storage.googleapis.com/go-build-log/ed530dbd/windows-386-2008_df30a50e.log\n\nConsult https://build.golang.org/ to see whether they are new failures. Keep in mind that TryBots currently test *exactly* your git commit, without rebasing. If your commit\u0027s git parent is old, the failure might\u0027ve already been fixed.\n\n",
      "parentUuid": "702036c4_9585f7e5",
      "tag": "autogenerated:trybots~failed",
      "revId": "879802f5a57eddfb8ce2baaa61055e5ab3eb301d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9cb6c17_38c1eefe",
        "filename": "slog/list.go",
        "patchSetId": 6
      },
      "lineNbr": 3,
      "author": {
        "id": 57259
      },
      "writtenOn": "2022-09-07T17:31:53Z",
      "side": 1,
      "message": "s/a functional/an immutable/",
      "range": {
        "startLine": 3,
        "startChar": 18,
        "endLine": 3,
        "endChar": 28
      },
      "revId": "879802f5a57eddfb8ce2baaa61055e5ab3eb301d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "89b0c984_ab66995f",
        "filename": "slog/list.go",
        "patchSetId": 6
      },
      "lineNbr": 3,
      "author": {
        "id": 14570
      },
      "writtenOn": "2022-09-07T20:49:51Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d9cb6c17_38c1eefe",
      "range": {
        "startLine": 3,
        "startChar": 18,
        "endLine": 3,
        "endChar": 28
      },
      "revId": "879802f5a57eddfb8ce2baaa61055e5ab3eb301d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f8b717eb_bd5ea200",
        "filename": "slog/list.go",
        "patchSetId": 6
      },
      "lineNbr": 18,
      "author": {
        "id": 57259
      },
      "writtenOn": "2022-09-07T17:31:53Z",
      "side": 1,
      "message": "Is the significant complexity of these two data structures (inline allocation in Record, and this pure-functional list) warranted? How much faster is it than a slice with small inline preallocation?\n\nIs the root of the problem that Record is immutable and that AddAttr is to be called multiple times? Would the problem be simpler if AddAttr accepted a slice and clients were encouraged to call it once only? That would allow you to use a single structure to support random access, assuming the linked list remains relatively shallow (or was depth-bounded, analogous to a self balancing tree).\n\nAlternatively, perhaps it would be simpler if instead of random access, you could only retrieve all of the attributes in a slice. What are the necessary access patterns for AddAttr and At?\n\nDo we expect AddAttr to be called for nearly every log event?\n\nI worry that the combined API constraints of immutability, single-element append, and single-element random access paints the implementation into a corner of rather esoteric pure-functional data structures such as those described in Okazaki\u0027s thesis and book.",
      "revId": "879802f5a57eddfb8ce2baaa61055e5ab3eb301d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6904f168_208cf8c9",
        "filename": "slog/list.go",
        "patchSetId": 6
      },
      "lineNbr": 18,
      "author": {
        "id": 14570
      },
      "writtenOn": "2022-09-07T20:13:05Z",
      "side": 1,
      "message": "\u003e How much faster is it than a slice with small inline preallocation?\n\nSlower I\u0027m sure, but the slice with preallocation suffers from aliasing.\n\n\u003e if AddAttr accepted a slice and clients were encouraged to call it once only\n\nI\u0027d want to support the following sequence of operations efficiently:\n\n1. Info(\"msg\", \"a\", 1, \"b\", 2) is called. It walks the ...any, constructing Attrs from key-value pairs, and builds a Record. (First problem: allocating the slice to pass to AddAttrs. Maybe we could use a pool here?)\n\n2. The Record is then passed to a Handler, which adds some Attrs and then passes it to another Handler. (Second problem: this is a second call to AddAttrs that seems hard to combine with the first. Third problem: how will the Handler allocate its slice of Attrs? Must every such handler use a pool to minimize allocations?)\n\n\u003e Alternatively, perhaps it would be simpler if instead of random access, you could only retrieve all of the attributes in a slice. What are the necessary access patterns for AddAttr and At?\n\nI think forward iteration is sufficient; I don\u0027t think there are any uses cases for random access. I was actually thinking of replacing At/NumAttrs with an Iter[Attr].",
      "parentUuid": "f8b717eb_bd5ea200",
      "revId": "879802f5a57eddfb8ce2baaa61055e5ab3eb301d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3d881bac_1a72dce5",
        "filename": "slog/list.go",
        "patchSetId": 6
      },
      "lineNbr": 18,
      "author": {
        "id": 57259
      },
      "writtenOn": "2022-09-09T12:33:06Z",
      "side": 1,
      "message": "\u003e 1. Info(\"msg\", \"a\", 1, \"b\", 2) is called. It walks the ...any, constructing Attrs from key-value pairs, and builds a Record. (First problem: allocating the slice to pass to AddAttrs. Maybe we could use a pool here?)\n\nAs we discussed yesterday: if Info is a static call and it only reads the ... slice, then the caller is free to allocate it on the stack, so there\u0027s no penalty for passing a constant number of attrs in this way.\n\n\n\u003e 2. The Record is then passed to a Handler, which adds some Attrs and then passes it to another Handler. (Second problem: this is a second call to AddAttrs that seems hard to combine with the first. Third problem: how will the Handler allocate its slice of Attrs? Must every such handler use a pool to minimize allocations?)\n\nAs we discussed, I agree with you that there are two choices to ensure that the first and second calls to AddAttr are efficient (allocation-free) in the common case where their total length is less than the 95%ile: (1) the record has an inline array of that size, in which case spillovers will be disproportionately more expensive; (2) we use pool allocation, in which case the API must have a Dispose() operation in the Record life cycle. I prefer the former on the grounds of simplicity... though I suppose one could argue that if we start with (2) we can always retreat to (1) later, and perhaps the fraction of users who have to engage with Records directly is very small.",
      "parentUuid": "6904f168_208cf8c9",
      "revId": "879802f5a57eddfb8ce2baaa61055e5ab3eb301d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "02c9c975_75920a75",
        "filename": "slog/list.go",
        "patchSetId": 6
      },
      "lineNbr": 59,
      "author": {
        "id": 57259
      },
      "writtenOn": "2022-09-07T17:31:53Z",
      "side": 1,
      "message": "This is a strange requirement, and it means that list{}.append(x).at(0) will panic. It should be mentioned in the doc comments.",
      "revId": "879802f5a57eddfb8ce2baaa61055e5ab3eb301d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "255498e5_7c61c484",
        "filename": "slog/list.go",
        "patchSetId": 6
      },
      "lineNbr": 59,
      "author": {
        "id": 14570
      },
      "writtenOn": "2022-09-07T20:49:51Z",
      "side": 1,
      "message": "Don\u0027t I do so here, and also in the fourth paragraph of the doc comment on the type?",
      "parentUuid": "02c9c975_75920a75",
      "revId": "879802f5a57eddfb8ce2baaa61055e5ab3eb301d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5ebecac6_c8652711",
        "filename": "slog/list.go",
        "patchSetId": 6
      },
      "lineNbr": 59,
      "author": {
        "id": 57259
      },
      "writtenOn": "2022-09-09T12:33:06Z",
      "side": 1,
      "message": "Yes, you do. Never mind me.",
      "parentUuid": "255498e5_7c61c484",
      "revId": "879802f5a57eddfb8ce2baaa61055e5ab3eb301d",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}