{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e2213ddc_c47b73f8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-01-24T14:44:29Z",
      "side": 1,
      "message": "TryBots beginning. Status page: https://farmer.golang.org/try?commit\u003df6e4c32a",
      "tag": "autogenerated:trybots~beginning",
      "revId": "f6e4c32a8475c4e2769e316c3523c1e55d08f4c5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "13569121_012ebec4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5976
      },
      "writtenOn": "2022-01-24T14:47:11Z",
      "side": 1,
      "message": "TryBots are happy.\n\n",
      "parentUuid": "e2213ddc_c47b73f8",
      "tag": "autogenerated:trybots~happy",
      "revId": "f6e4c32a8475c4e2769e316c3523c1e55d08f4c5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ad7d6444_9739a301",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 44008
      },
      "writtenOn": "2022-01-24T17:25:32Z",
      "side": 1,
      "message": "This definition of FuncNode closely follows the definition of call graph node (https://pkg.go.dev/golang.org/x/tools/go/callgraph#Node) and what was proposed in the vulncheck design doc. IDs simplify things when serialization comes into picture as equality of two FuncNodes can be checked by their equality of their IDs.\n\nThoughts?",
      "revId": "f6e4c32a8475c4e2769e316c3523c1e55d08f4c5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "76827046_3178a60e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 14570
      },
      "writtenOn": "2022-01-24T17:47:48Z",
      "side": 1,
      "message": "The existing API is more cumbersome for users. In the code I was writing, I had to first get the ID then look it up. It\u0027s simpler just to access the *FuncNode.\n\nI didn\u0027t see any serialization in the code. Where do you think it will be needed? Note that common serialization packages (encoding/gob, encoding/json, etc.) do not preserve topology (i.e. they will write the same *FuncNode twice), whether or not there is an ID. To serialize properly you\u0027d need to write custom code or use something that can handle sharing, like https://github.com/jba/codec.\n\nBut maybe I don\u0027t understand your point. After all, equality of two FuncNodes can be checked by pointer comparison as well as ID comparison.",
      "parentUuid": "ad7d6444_9739a301",
      "revId": "f6e4c32a8475c4e2769e316c3523c1e55d08f4c5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34e1787e_0a06d590",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 44008
      },
      "writtenOn": "2022-01-24T18:00:46Z",
      "side": 1,
      "message": "My point about serialization is that if this data structure is, say, received over network, then clients can\u0027t use pointer equality to check if two FuncNodes are equal. IDs would help them here.\n\nChecking node equality via Name, RecvType, and PkgPath will also not cut it in general. If Calls graph is a product of a context-sensitive analysis then we could have two nodes from two different context with the same \u003cName, RecvType, PkgPath\u003e. IDs again help here.\n\nDoes this make sense?",
      "parentUuid": "76827046_3178a60e",
      "revId": "f6e4c32a8475c4e2769e316c3523c1e55d08f4c5",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705"
    }
  ]
}